   ------
   Kurento Android SDK developer's guide
   ------
   ------
   Date
   ------


Crear una aplicación en Android

* Configuración del fichero AndroidManifest.xml
	
	La configuración del fichero AndroidManifest.xml dentro de una aplicación basada en Android es muy importante, debido a que en este fichero se encuentran por un lado definidos los permisos que deberá aceptar el usuario cuando se instale la aplicación, y por otro las actividades y los servicios de los cuales estará compuesta la aplicación.
	
		Algunos de los permisos necesarios son:

---
	<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
	<uses-permission android:name="android.permission.CAMERA"></uses-permission>
	<uses-permission android:name="android.permission.RECORD_AUDIO"></uses-permission>
	<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
	<uses-permission android:name="android.permission.INTERNET"></uses-permission\>
	<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>
	<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
	<uses-permission android:name="android.permission.READ_CONTACTS"></uses-permission>
	<uses-permission android:name="android.permission.WRITE_CONTACTS"></uses-permission>
	<uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission>
---
			
		Dependiendo de que tipo de aplicación se quiera implementar algunos de estos permisos no serán necesarios. Para conocer todos los permisos de los que se dispone se pueden consultar en la {{{http://developer.android.com/reference/android/Manifest.permission.html}guía de desarrollo de Android}}.
		
		Por otro lado, también se definirán las actividades y los servicios que compondrán nuestra aplicación, como por ejemplo:
		
			* Un servicio se define como:
			
--- 
	<service android:enabled="true" android:name="com.tikal.softphone.SoftPhoneService" \>
---

			* Una actividad se define como:
			
---			
	<activity android:name="com.tikal.videocall.VideoCall" 	android:label="Video Call" 
	android:theme="@android:style/Theme.NoTitleBar.Fullscreen" android:screenOrientation="landscape" 
	android:launchMode="singleTop" \>
---
				
		Cada una de las actividades que vayan a ser lanzadas dentro de la aplicación deben ser definidas en este fichero. Para más información sobre la configuración del fichero AndroidManifest.xml se pueden consultar en la {{{http://developer.android.com/guide/topics/manifest/manifest-intro.html}guía de desarrollo de Android}}.

		Por último, en la configuración de la actividad principal deberá incluirse un apartado llamado <<{{{http://developer.android.com/guide/topics/manifest/intent-filter-element.html}intent-filter}}>> que nos servirá para cuando un usuario quiera realizar una llamada desde los contactos según el "scheme" que nosotros elijamos, en este caso se busca que cuando un usuario tenga guardado un contacto con datos como "sip:juan@server.net"> se abra nuestra actividad:
		
---
	<intent-filter>
		<action android:name="android.intent.action.SENDTO" \>
		<category android:name="android.intent.category.DEFAULT" \>
		<data android:scheme="sip" \>
		<data android:scheme="imto" \>
	<\intent-filter> 
---	
	
* Actividades

	** {{Actividad principal}}
	
	** Gestión de {{preferencias}} de {{Conexión}}
	
	** Gestión de {{preferencias}} del {{Media}} 
	
	** Gestión de la {{Recepción}} de una llamada 
	
	** Gestión de la {{Emisión}} de una llamada 
	
	** {{Gestión del media}} ({{Vídeo}} y {{Audio}})


* {{Servicios}}

	** {{Servicio principal}}
	
	** {{Servicio para una llamada activa}}


* Controller

	Deberá existir una clase que debe implementar varias interfaces: <<<SipEndPointListener, SipCallListener, IPhone y CallNotifier>>>. A está clase la llamaremos para entender su funcionamiento <<"controller">>. Será la encargada de controlar y gestionar todos los eventos SIP que nos puedan llegar o que podamos enviar, de implementar los comportamientos normales de un teléfono como aceptar una llamada, rechazarla, etc... A esta clase se añadirán "listener" y será el <<controller>> quien les irá avisando de qué está pasando.

** SipEndPointListener

	Este interfaz representa un método encargado de recibir eventos del tipo <<<SipEndPointEvent>>>:
	
	*<<<onEvent()>>>

*** <<<onEvent()>>>

	La implementación de este método en la clase <<controller>> deberá ser capaz de tratar los siguientes eventos:
		
		* <<<INCOMING_CALL>>>, la recepción de este evento significa que alguien nos está realizando una llamada, por lo que desde la clase <<controller>> hay que notificar al <<<listener>>> que se haya agregado que está llegando una llamada. En este caso habrá que invocar a un método de un objeto de la interfaz <<<CallListener>>>, de la cual hablaremos en el {{Servicio principal}} que será quien implemente esta interfaz, llamado <<<incomingCall(String uri)>>>.  Básicamente lo que hará será levantar la actividad encargada de la recepción de llamadas.
	
		* <<<REGISTER_USER_SUCESSFUL>>>, la recepción de este evento significa que el registro con los parámetros de configuración de conexión son correctos y hemos podido registrarnos en el servidor. En este caso al igual que en el anterior, será un método de un objeto de la interfaz <<<CallListener>>> a quien tendremos que invocar, llamado <<<registerUserSucessful()>>>. Este método se encargará de hacerle saber al usuario de la aplicación que su registro ha sido correcto.

		* <<<REGISTER_USER_FAIL>>>, la recepción de este evento significa al contrario que el evento anterior que el registro ha sido incorrecto. El método al que se llamará será <<<registerUserFailed()>>>  y se encargará de hacerle saber al usuario de la aplicación que su registro ha sido incorrecto.
	

** SipCallListener

	Este interfaz representa un método encargado de recibir eventos del tipo <<<SipCallEvent>>>:
	
	*<<<onEvent()>>>

*** <<<onEvent()>>>

	La implementación de este método en la clase <<controller>> deberá ser capaz de tratar los siguientes eventos, al igual que en el apartado anterior la llamada a los métodos serán de un objeto de la interfaz <<<CallListener>>> que serán implementados por el {{Servicio principal}}:

	* <<<CALL_SETUP>>>, la recepción de este evento significa que la llamada ha sido establecida y que por lo tanto se puede cerrar la actividad encargada de gestionar o bien la emisión de llamadas o bien la recepción de llamadas y empezar la actividad y el servicio que se encargará de gestionar el media, tanto el vídeo como el audio. Esto se hará llamando al método <<<callSetup(NetworkConnection networkConnection)>>>.

	* <<<CALL_TERMINATE>>>, la recepción de este evento significa que la llamada ha sido terminada por alguno de los usuarios, por lo tanto habrá que parar el servicio y la actividad que se encarga de gestionar una llamada activa. Esto se hará llamado al método <<<callTerminate()>>>.
	
	* <<<CALL_REJECT>>>, la recepción de este evento significa que la llamada ha sido rechazada por el contacto, por lo que habrá que cerrar la actividad que se encarga de gestionar la emisión de llamadas. Esto se hará llamando al método <<<callReject()>>>.
		

** IPhone 

	Esta interfaz representa las acciones básicas de un teléfono:
	
		* <<<aceptCall()>>>. Aceptar una llamada entrante.

		* <<<reject()>>>. Rechazar una llamada entrante.

		* <<<call(String remoteURI)>>>. Realizar una llamada saliente a un contacto.

		* <<<hang()>>>. Colgar una llamada en curso.

*** <<<aceptCall()>>>
	
	Este método de la clase <<controller>> se llamará desde la actividad que se encargue de la gestión de las llamadas entrantes. La implementación de este método debe recoger los datos de la llamada y llamar al método <<<accept()>>> de la clase <<<SipCall>>>. De esta manera se podrá enviar mediante el protocolo SIP que la llamada ha sido aceptada.

*** <<<reject()>>>

	Este método de la clase <<controller>> se llamará desde la actividad que se encargue de la gestión de las llamadas entrantes también. La implementación de este método debe recoger los datos de la llamada y llamara al método <<<reject()>>> de la clase <<<SipCall>>>. De esta manera se podrá enviar mediante el protocolo SIP que la llamada ha sido rechazada.


*** <<<call(String remoteURI)>>>

	Este método de la clase <<controller>> se llamará desde la actividad principal de la aplicación o desde la actividad que se encargue de gestionar la emisión de llamadas a partir de un contacto. Deberá tener como parámetro la Uri del contacto al que se quiere realizar la llamada. En la implementación de este método, se usará un objeto de la clase <<<SipEndPoint>>>, que será definido en el registro del usuario (se verá en el apartado que donde se registran los usuarios), usando el método <<<dial(String remoteParty, Direction direction, SipCallListener callController)>>> el cual se encargará de enviar mediante el protocolo SIP el mensaje de invitación.

*** <<<hang()>>>

	Este método de la clase <<controller>> se llamará desde la actividad que gestione una llamada activa. La implementación de este método usará un objeto de la clase <<SipCall>> para llamar a su método <<<hang()>>> de esta manera usando el protocolo SIP se podrá enviar el mensaje de finalización de llamada.


** CallNotifier

	Este interfaz representa dos métodos para poder añadir o eliminar <<listener>> del tipo interfaz <<<CallListener>>>, como se ha comentado antes será implementado en el {{Servicio principal}}:
	
		* <<<addListener(CallListener listener)>>>. Añadir un <<listener>>.

		*<<<removeListener(CallListener listener)>>>. Eliminar un <<listener>>.


{Actividad principal}

{Servicios}

	La creación de los servicios es necesaria para poder controlar ciertos eventos que pueden ocurrir cuando la aplicación no está en primer plano. Para ello se deberían crear dos servicios, uno que gestione todos los eventos de la conexión SIP y otro que gestione el media durante una llamada.

* {Servicio principal}

	El servicio principal de la aplicación será el encargado de controlar los eventos que puedan surgir desde SIP, por ello, es el encargado de implementar la interfaz {{<<<CallListener>>>}}. 

	Algunas de las responsabilidades que tendrá este servicio son:

	* Cuando desde la aplicación principal se arranque el servicio, debería iniciar la notificación de que la aplicación está abierta en la barra de notificaciones. A la hora de crear la notificación se debería asociar la actividad principal a esta notificación.

	* Agregarse mediante el método  <<<addListener()>>> del objeto <<controller>>, que recuperaremos gracias a <<<ApplicationContext>>>,  para poder recibir los eventos anteriormente mencionados. De esta manera desde <<controller>> se podrá llamar a nuestra implementación de <<<CallListener>>>.

	* Cuando recibamos una llamada a <<<incomingCall(String uri)>>>, se deberá iniciar la actividad que gestione la recepción de llamadas. De esta manera será el usuario el que podrá aceptar o rechazar la llamada. Por otro lado, gracias a que estamos usando un servicio, cada vez que este método sea invocado y aunque la aplicación esté en segundo plano se podrá levantar dicha actividad.

	* Cuando recibamos una llamada a <<<registerUserSucessful()>>>, se deberá indicar a la actividad principal mediante un mensaje que el usuario se ha registrado correctamente para que ésta pueda notificárselo al usuario mediante algún mensaje.

	* Cuando recibamos una llamada a <<<registerUserFailed()>>>, se deberá indicar a la actividad principal mediante un mensaje que el usuario no se ha registrado correctamente para que ésta pueda notificárselo al usuario mediante algún mensaje.

	* Cuando recibamos una llamada a <<<callSetup(NetworkConnection networkConnection)>>>, se deberá indicar a la actividad principal mediante un mensaje que debe para la actividad de emisión de llamadas o de recepción de llamadas según sea el caso. Además, se deberá arrancar el {{Servicio para una llamada activa}}.

	* Cuando recibamos una llamada a <<<callTerminate()>>>, se deberá para el {{Servicio para una llamada activa}}.

	* Cuando recibamos una llamada a <<<callReject()>>>, se deberá indicar a la actividad principal mediante un mensaje que debe parar la actividad encargar de emisión de llamadas, ya que sólo nos podrán rechazar una llamada cuando la realicemos nosotros.

	* Por último, cuando se finalice la aplicación el servicio será en encargado de eliminar la notificación de la barra de notificaciones y además cerrar el {{Servicio para una llamada activa}} para evitar que se quedase corriendo.

	
**{CallListener}

	Esta interfaz representa los eventos que podremos recibir desde SIP:
	
		* <<<incomingCall(String uri)>>>. Este evento nos indicará que estamos recibiendo una invitación a una llamada.

		* <<<registerUserSucessful()>>>. Este evento nos indicará que el usuario se ha registrado correctamente.

		* <<<registerUserFailed()>>>. Este evento nos indicará que el usuario no se ha registrado correctamente.

		* <<<callSetup(NetworkConnection networkConnection)>>>. Este evento nos indicará que la llamada se ha establecido correctamente por parte de los usuarios.

		* <<<callTerminate()>>>. Este evento nos indicará que la llamada ha finalizado.
		
		* <<<callReject()>>>. Este evento nos indicará que la llamada ha sido rechazada.

* {{Servicio para una llamada activa}}

	Este servicio será el encargado de gestionar una llamada activa y será creado desde el servicio principal cuando se ha establecido una llamada correctamente.

	* Cuando se crea el servicio, uno de los primeros pasos que debe hacerse es cambiar la notificación que tenemos en la barra de notificaciones para indicar que tenemos una llamada activa, de este modo si salimos al menú principal o a la agenda, etc... podemos volver a la llamada sin problemas. La notificación estará asociada a la actividad que se encargue de mostrar el media en el dispositivo.

	* Durante la creación del servicio, también se crearan los componentes de audio, tanto para la emisión como para la recepción. Los componentes de vídeo se crearan en la actividad encargada de mostrar el media en el dispositivo, esto es así para poder seguir enviando audio si la aplicación está en segundo plano, pero no vídeo. Para poder crear los componentes de audio usaremos uno de los métodos de <<<MediaSessionAndroid>>>.

		** <<<createMediaComponent>>>, le indicaremos el tipo de componente que necesitamos, si es de emisión o de recepción, además de el altavoz por el cual queremos recibir. En el siguiente ejemplo, estaríamos creando un componente de recepción de audio y se reproducirá por el altavoz externo:

---
	Parameters params = new ParametersImpl();
	params.put(MediaComponentAndroid.STREAM_TYPE, AudioManager.STREAM_MUSIC);
	audioRecorderComponent = mediaSession.createMediaComponent(MediaComponentAndroid.AUDIO_RECORDER, params);
---		

	* Cuando el servicio ha comenzado, y hemos creado los componentes de audio correctamente, debemos definir como será cada componente, sí de emisión o de recepción y hacerlos empezar. De la siguiente manera, seleccionaríamos que el componente que hemos creado anteriormente es de recepción y que puede comenzar.

---
	audioRecorderComponent.join(Direction.RECV,
						nc.getJoinableStream(StreamType.audio));
	audioRecorderComponent.start();
---

	* Una vez los componentes de audio han comenzado, se deberá arrancar la actividad que se encargará de mostrar el media en el dispositivo, entonces crearemos los componentes de vídeo.

	* Cuando se destruye el servicio, éste deberá:

		** Volver a cambiar la notificación de la barra de notificaciones a la notificación principal.

		** Detener los componentes de audio.

---
	audioRecorderComponent.stop();	
---

		** Avisar a la actividad que se encarga de mostrar el media en el dispositivo que debe cerrarse.


Gestión de {preferencias}

* {Conexión}

	En las preferencias de conexión deberemos dejar configurar los siguientes datos:
	
	** <<Usuario>>: será el usuario con el que quedará registrado en el servidor SIP.

	** <<Dominio>>: será el dominio con el que quedará registrado en el servidor SIP.

	** <<Ip del servidor SIP>>: será el servidor donde se registraran los usuarios.

	** <<Puerto del servidor SIP>>: será el puerto del servidor.

	Con estos datos, más adelante veremos que pasos hay que seguir para registrarse en el servidor.

* {Media}

Gestión de emisión y recepción de llamadas

	Tanto para la emisión como para la recepción de llamadas podemos tener dos actividades que nos representen que un contacto nos está llamando o bien que le estamos llamando nosotros.

* {Emisión} de llamadas

	La actividad que se encargue de la emisión de llamadas será creada cuando se haya elegido un contacto o se sepa a que contacto se quiere realizar la llamada y debería mostrar en la pantalla como mínimo:
	
		** El nombre del contacto.

		** La imagen del contacto, si éste lo tuviera.

		** Un botón para cancelar la llamada.

	Esta actividad no deberá hacer nada más que mostrar la interfaz para que el usuario sepa que se está realizando una llamada y que puede cancelarla. La realización de la llamada se encargará la clase <<controller>> que hemos definido anteriormente. 

	El cierre de esta actividad puede venir dada por 3 circunstancias:

		** El contacto rechaza la llamada.
		
		** El contacto acepta la llamada.
	
		** El usuario cancela la llamada.


* {Recepción} de llamadas

	La actividad que se encargue de la recepción de llamadas será creada a partir del servicio encargado de controlar los eventos SIP que puedan llegar, como sería un <invite> en el caso de una recepción de llamada. La interfaz de esta actividad debería mostrar en la pantalla como mínimo:

		** El nombre del contacto.
		
		** La imagen del contacto, si éste lo tuviera.

		** Un botón para aceptar la llamada. Cuando se pulse, se deberá notificar a <<controller>> que la llamada se ha aceptado y cerrar la actividad.

		** Un botón para cancelar la llamada. Cuando se pulse, se deberá notificar a <<controller>> que la llamada se ha rechazado y cerrar la actividad.
	
		** Vibrar e incluso hacer sonar el sonido del dispositivo. Cuando se acepte o se rechace la llamada la vibración y/o el sonido deberá cesar.

	Como se ha comentado anteriormente, el cierre de esta actividad puede venir dada por 3 circunstancias:
		
		** Quien llama cancela la llamada.
	
		** Se rechaza la llamada.

		** Se acepta la llamada.
	

{Gestión del media} (Vídeo y Audio)

* {Vídeo}

* {Audio}

Otras clases de ayuda

	Estas clases que se mencionan a continuación, son clases que se pueden crear para facilitar la labor de desarrollo de algunas de las funcionalidades que pueda tener la aplicación.

* Almacenamiento de datos para interactuar entre las clases

	Está clase nos servirá para poder compartir algunos datos entre todas las actividades y no perder información cuando la actividad esté en segundo plano. Simplemente será una tabla Hash en la que iremos almacenando y recogiendo datos según los necesitemos.

---
	public static HashMap<String, Object> contextTable = new HashMap<String, Object>();
---


* Obtener la ip actual

	Recoger la ip de un dispositivo Android, en muchas de las aplicaciones es algo que se puede necesitar muy a menudo, por lo que se recomienda realizar una pequeña clase que nos ayude con esta tarea. Un ejemplo de la función sería:

---
	public static InetAddress getLocalAddress() {
		try {
			for (Enumeration<NetworkInterface> en = NetworkInterface
					.getNetworkInterfaces(); en.hasMoreElements();) {
				NetworkInterface intf = en.nextElement();
				for (Enumeration<InetAddress> enumIpAddr = intf
						.getInetAddresses(); enumIpAddr.hasMoreElements();) {
					InetAddress inetAddress = enumIpAddr.nextElement();
					if (!inetAddress.isLoopbackAddress()
							&& (inetAddress instanceof Inet4Address)) {
						return inetAddress;
					}
				}
			}
		} catch (SocketException e) {
			e.printStackTrace();
		}
		return null;
	}
---


* Obtener datos de los contactos de la agenda

	Para tener una mayor facilidad a la hora de obtener datos de los contactos, es recomendable crearse una clase que se encargue de ello a partir de la uri del usuario. De esta manera, podremos recoger el nombre, la foto, la música asociada a ese contacto. 

	De esa manera podremos hacer consultas del estilo:

		* <<<getName(Integer id)>>> donde obtendremos el nombre del contacto según su identificador dentro de los contactos. Esto nos servirá cuando elijamos a un contacto desde el acceso a los contactos de la aplicación.

		*<<<getName(Intent data)>>> donde obtendremos el nombre del contacto después de elegir el contacto directamente desde la agenda sin pasar por la aplicación.

		*<<<getId(String sipUri)>>> donde obtendremos el id del contacto en la agenda a partir de su identificador SIP.

		*<<<getId(Intent data)>>> donde obtendremos el id del contacto en la agenda.

		*<<<getSip(Intent data)>>> donde obtendremos el identificador SIP después de elegir el contacto directamente desde la agenda sin pasar por la aplicación.

		*<<<getPhoto(Integer id)>>> donde obtendremos la imagen del contacto, si tiene.


Ejemplos

Fragmentos de código fuente
