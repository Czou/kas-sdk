   ------
   Kurento Android SDK developer's guide
   ------
   ------
   Date
   ------
 

Introduction

	This guide provides required information to incorporate Kurento Android SDK (KAS)
	to applications. Three main blocks are found through the document

		* <<Control Plane>>: Describes the KAS' SIP User Agent control interface. Contains
		detailed information regarding contact management and call handling.

		* <<User Plane>>: Shows the mechanisms available to build a media distribution network associated with a call.
Provides details of core configuration average, as the building blocks that allow connection of
multimedia devices to networks for the transmission and reception of audio and video.

		* <<Application Android>>. Are the steps needed to create an application that incorporates Kurento Android Android SDK.

Control Plane

	Control function is formed by a SIP Agent that supports connectivity with VoIP networks. Presents the architecture shown in the figure below.

[images/diagrama-control-plane.png]

* Concepts

** <<UA>>

	This object is responsible for all management of the SIP protocol. Send, receive, process SIP messages for to sent by the network. This object can communicate to multiple contacts (<<<SipEndPoint>>>).


*** <<<registerEndPoint(String user, String realm, String password, int expires, SipEndPointListener handler)>>>

	This method registers a user to the server that is defined in the configuration of the object <<<ua>>>. Furthermore, it tells who is responsible for receiving events generated.

	The parameter <<<expires>>> indicates the maximum time for each register, also you can unregister the user by setting this value to 0.

***<<<terminate()>>>

	This method ends the SIP stack, furthermore the user unregister the server.
	
**  <<SipEndPoint>>. 

	This object is the representation of a <<<sipuri>>>, a contact. It is responsible for conventional tasks of a call, accept,  cancel, reject ...

***<<<dial(String remoteParty, SipCallListener callController)>>>

	This method makes a call to a contact. Using the parameter <<<remoteParty>>>  to configurate <<<sipuri>>>, it's the contact you want to call. 
	Furthermore, it tells who is responsible for receiving events that may be generated. This will generate a message of SIP protocol that  send an invitation for communication.

**  <<SipEndPointEvent>>. 

	This object provides events that are received after making a register in a SIP server. To receive events is necessary to implement the interface <<<SipEndPointListener>>> and 
	subscribe to object <<<SipEndPoint>>> which we want to receive such events. This subscription is done when the user is register.
	
		***<<<SipEndPointListener>>>
	
			This interface represents a method for receiving events of type <<<SipEndPointEvent>>>:
	
			*<<<onEvent()>>>

		The implementation of this method should be able to handle the following events:
		
			* <<<INCOMING_CALL>>>, this event means that someone is making call to us.

			* <<<REGISTER_USER_SUCESSFUL>>>, this event means that the register with the connection settings are correct and we are registered. 

			* <<<REGISTER_USER_FAIL>>>, this event signifies that registration was incorrect.
	
			* <<<REGISTER_USER_NOT_FOUND>>>, this event means that the user does not exist and the register has been wrong.


+---
@Override
public void onEvent(SipEndPointEvent event) {
	SipEventType eventType = event.getEventType();
	if (SipEndPointEvent.INCOMING_CALL.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
	if (SipEndPointEvent.REGISTER_USER_SUCESSFUL.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
	if (SipEndPointEvent.REGISTER_USER_FAIL.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
	if (SipEndPointEvent.REGISTER_USER_NOT_FOUND.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
}
+---

**  <<SipCall>>. 

	This object handles the call once created. In addition to managing it, we may collect information from the media that has been established in the negotiation.
	
***<<<accept()>>>

	This method accepts an incoming call. This generates a SIP message accepting the call.

***<<<reject()>>>

	This method rejects an incoming call. This generates a SIP message of rejecting the call.

***<<<hangup()>>>

	This method ends a call. This generates a SIP message of ending the call.

***<<<cancel()>>>

	This method cancels the invitation to establish a connection. This will generate a SIP message canceling the call.
	
***<<<getNetworkConnection(JoinableStream.StreamType media)>>>

	This method can obtain the <<<NetworkConnection>>> that has been generated in the SIP stack configuration.	
	
***<<<getMediaTypesModes()>>>

	This method can know the direction of the communication (send only, receive only, send / receive) from each stream of the communication.

**  <<SipCallEvent>>.

	This object lets us know the events that will be received during the establishment of a call. To receive events is necessary to implement the interface <<<SipCallListener>>> 
	and subscribe to object <<<SipCall>>> which we want to receive such events.
	
		*** <<<SipCallListener>>>. 

			This interface represents a method for receiving events of type <<<SipCallEvent>>>:
	
			*<<<onEvent()>>>

		The implementation of this method should be able to handle the following events:

			* <<<CALL_SETUP>>>, this event means that the call has been established.

			* <<<CALL_TERMINATE>>>, this event means that the call has been terminated by any user.
	
			* <<<CALL_REJECT>>>, this event means that the call has been rejected by the contact.
		
			* <<<CALL_CANCEL>>>, this event means that the user who made the call has been canceled before it has been established.
	
			* <<<CALL_ERROR>>>, this event means that has not been able to locate the requested contact


+---
@Override
public void onEvent(SipCallEvent event) {
	SipEventType eventType = event.getEventType();

	if (SipCallEvent.CALL_SETUP.equals(eventType)) {
		currentCall = event.getSource();
		// Process the event.
	} else if (SipCallEvent.CALL_TERMINATE.equals(eventType)) {
		// Process the event.
	} else if (SipCallEvent.CALL_REJECT.equals(eventType)) {
		// Process the event.
	} else if (SipCallEvent.CALL_ERROR.equals(eventType)) {
		// Process the event.
	}
}
+---

** <<SipConfig>>. 

	The definition of an object of this class is required for the initialization of the SIP stack. Get the parameters of the network configuration.

** <<MSControlFactory>>. 

	It is the main factory provides a static method to create <<<MediaSessionAndroid>>>.

**  <<MediaSessionAndroid>>. 

	An object of this class acts as a factory to create object <<<MediaComponentAndroid>>>. This creates a <<<MediaComponentAndroid>>> based on the particular configuration and 
	the parameters passed into the method <<<createMediaComponent>>>. An object of this class is assigned to <<<UAFactory>>> using the static method <<<setMediaSession>>> through 
	this object and builds a <<<NetworkConnection>>>.
	
***<<<createMediaComponent(Configuration<MediaComponent> predefinedConfig, Parameters params)>>>

	This method creates the components of media (audio and video).
	
** <<MediaComponentAndroid>>. 

	An object of this class define a particular media component, according to the settings.

* SIP Agent initialization.

	The User Agent must be initialized to start the application. Serves one or more SIP termination points and manages all calls: 
	incoming and outgoing calls. Must be restarted only when significant changes occur, such as an IP change, active interface, 
	the proxy or similar.
	
	Internally it have a SIP stack that handles the exchange of messages between remote agents. Kurento Android SDK used for this purpose 
	the implementation {{{http://java.net/projects/jsip}JAIN-SIP}}

	The initialization of the SIP user agent configuration requires two sets of parameters:
	
	* <<Configuration SIP>>: Sets the configuration required to connect to a VoIP network. It consists of the parameters shown in the next table.
	
	
*--------*-----------*----*--------*----------------------------------------------------------------*
| <<Name>> | <<M/O>> |<<Type>>|<<Range>>    | <<Description>>                                                    |
*--------*-----------*----*--------*----------------------------------------------------------------+
| LocalAddress| M | String | NA    | Sets the IP address used by the SIP stack. If the IP address does not |
|             |   |        |       | correspond to an active interface, then it generate an exception  |
*--------*-----------*----*--------*----------------------------------------------------------------+
| LocalPort   | O | Integer| 1-2^16| Sets the local port where the SIP stack send and heard the messages|
*--------*-----------*----*-------*----------------------------------------------------------------+
| ProxyAddress| M | String | NA    | Set the SIP proxy address. This is also the address used |
|             |   |        |       |as a SIP REGISTER                           |
*--------*-----------*----*-------*----------------------------------------------------------------+
| ProxyPort| M | String |  1-2^16  | Set the SIP proxy port that SIP messages are sent|
*--------*-----------*----*-------*----------------------------------------------------------------+
(M: Mandatory; O: Optional)


	* <<Configuration of media>>: It provides relevant information required of media in the process of negotiating calls. 
	The following table lists the parameters:


*--------*-----------*----*-------*--------------*--------------------------------------------------*
| <<Basic parameters>> | <<M/O>> | <<Type>> | <<Range>> | <<Default value>> | <<Description>> |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| NET_IF |  M | NetIF | [WIFI, MOBILE] | | Indicate if the network interface is WIFI or MOBILE. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| LOCAL_ADDRESS | M | InetAddress | NA | |Indicate the local IP address.|
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| MAX_BANDWIDTH | O | Integer | NET_IF.MOBILE:\ [150000,\ 384000]\ | NET_IF.MOBILE:\ 384000\ | Indicate the max bandwidth will be used in bps(bits per second). |
|				|	|		  | NET_IF.WIFI:\ [150000,\ 1500000]	| NET_IF.WIFI:\ 1500000  |																	|	
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| STREAMS_MODES | O | Map\<MediaType,\ Mode\> | [SENDRECV, SENDONLY, RECVONLY] | SENDRECV | Indicate the mode of each media stream.|
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| AUDIO_CODECS   | O | List\<AudioCodectype\> | [AMR, MP2] | [AMR, MP2] |Indicate the audio codecs supported. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| VIDEO_CODECS   | O | List\<VideoCodectype\> | [H263, MPEG4]| [H263, MPEG4] |	Indicate the video codecs supported. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| <<Advanced parameters>> |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| FRAME_SIZE | O | Dimension | NA | 352x288 | Indicate the frame size in pixels (width x height).  |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| MAX_FRAME_RATE | O |Integer|  [1, MAX_INT] | 15 |Indicate the max frame rate will be used. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| GOP_SIZE | O |Integer| [0, MAX_INT] | 6 | Indicate the max number of frames in a group of pictures, or 0 for intra_only.  |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| FRAMES_QUEUE_SIZE | O | Integer | [2, MAX_INT] | 2 | Indicate the number of frames will be buffered from the camera. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
(M: Mandatory; O: Optional)
	
	
	The initialization of the SIP agent first requires factory parameterize the mean <<MSControlFactory>>, as shown in the following snippet.
	
+---
Parameters params = new ParametersImpl();

NetIF netIF = NetIF.MOBILE;
params.put(MediaSessionAndroid.NET_IF, netIF);

InetAddress localAddress = NetworkIP.getLocalAddress();
params.put(MediaSessionAndroid.LOCAL_ADDRESS, localAddress);

int maxBW = 384000;
params.put(MediaSessionAndroid.MAX_BANDWIDTH, maxBW);

Map<MediaType, Mode> callDirection = new HashMap<MediaType, Mode>();
callDirection.put(MediaType.VIDEO, Mode.SENDONLY);
callDirection.put(MediaType.VIDEO, Mode.RECVONLY);
callDirection.put(MediaType.VIDEO, Mode.SENDRECV);
callDirection.put(MediaType.AUDIO, Mode.SENDONLY);
callDirection.put(MediaType.AUDIO, Mode.RECVONLY);
callDirection.put(MediaType.AUDIO, Mode.SENDRECV);
params.put(MediaSessionAndroid.STREAMS_MODES, callDirection);

ArrayList<AudioCodecType> audioCodecs = new ArrayList<AudioCodecType>();
audioCodecs.add(AudioCodecType.AMR);
audioCodecs.add(AudioCodecType.MP2);
params.put(MediaSessionAndroid.AUDIO_CODECS, audioCodecs);

ArrayList<VideoCodecType> videoCodecs = new ArrayList<VideoCodecType>();
videoCodecs.add(VideoCodecType.H263);
videoCodecs.add(VideoCodecType.MPEG4);
params.put(MediaSessionAndroid.VIDEO_CODECS, videoCodecs);

Dimension frame_size = new Dimension();
params.put(MediaSessionAndroid.FRAME_SIZE, frame_size);

int maxFR = 15;
params.put(MediaSessionAndroid.MAX_FRAME_RATE, maxFR);

int gopSize = 6;
params.put(MediaSessionAndroid.GOP_SIZE, gopSize);

int maxQueueSize = 2;
params.put(MediaSessionAndroid.FRAMES_QUEUE_SIZE, maxQueueSize);
+---	

	Also need to set the factory in SIP User Agents, as follows.
	
+---
SipConfig sipConfig = new SipConfig();
sipConfig.setLocalAddress(localAddress.getHostAddress());
sipConfig.setLocalPort(6060);
sipConfig.setProxyAddress(proxyIP);
sipConfig.setProxyPort(proxyPort);
+---

	Once the factories are set up, you instantiate an object <<MediaSession>> passed as parameter to instantiate a SIP User Agent.

+---
mediaSession = MSControlFactory.createMediaSession(params);
UaFactory.setMediaSession(mediaSession);

ua = UaFactory.getInstance(sipConfig);
+---

	It is important to note that a change in media parameters required to instantiate a new <<<MediaSession>>> and so reset both a user agent.
	
	To finalize the User Agent, either because the application is finished, or because it is necessary to reconfigure, the code that  runs is
	
+---
ua.terminate();
+---


* Register control

** Register

	Once the SIP stack is initialized and have our object <<<ua>>> created successfully, a user can register into a server. Registration in the server can be authenticated or not. Depending on the server and the application being made, so will the values ​​you enter in the call to <<<registerEndPoint(String user, password, String String int expires, realm, SipEndPointListener handler)>>>:

	* <<user>>: User registration.

	* <<realm>>: User domain to register.

	* <<password>>: User password for registration.

	* <<expires>>: Time until the next register.

	* <<handler>>: Class that is responsible for implementing the interface <<<Sip EndPoint Listener>>>.

	The register will return an object of type <<<SipEndPoint>>> with which we can make calls. Furthermore the class has to implement the interface will begin to receive the corresponding events.

+---
endPoint = ua.registerEndPoint(localUser, localRealm, localPassword, expires, this);
+---

** Unregister

	If for any reason wish to stop receiving calls or the application has finished, we will unregister the contact  on the server. Set the parameter <<<expires>>> with a value of 0.

+---
expires = 0;
endPoint = ua.registerEndPoint(localUser, localRealm, localPassword, expires, this);
+---

* Outgoing calls

** Make calls

	To make an outgoing call indicated the contact you want to make the call with an <<<sipuri>>>, which will consist of the username and domain, for example: <<<user@dominio.es>>> . The call is made by the object <<<endpoint>>> of class <<<SipEndPoint>>> that we obtained when we have completed the registration of the user. Furthermore, we tell the class that implements the interface <<<SipCallListener>>>. This returns an object of class <<<SipCall>>>.
	
+---
currentCall = endPoint.dial(remoteURI, this);
+---

	For events that occurs when a call is made it, must implement the interface <<<SipEndPointListener>>>.

** Cancel calls

	We may cancel a call before it is established. We will use an object of class <<<SipCall>>> that is created when we started the outgoing call.
	
+---
currentCall.cancel(); 
+---	

* Incoming calls

	When you register, it also indicates the class that implements <<<SipEndPointListener>>>. This is necessary to receive some events, including the event <<<SipEndPointEvent.INCOMING_CALL>>>. 
	When we receive this event:

	* Accept call.

	* Reject call.

** Accept call

	To accept the call, we use the method <<<accept()>>> of the class <<<SipCall>>>.

+---
this.pendingEndPointEvent = event;
incomingCall = pendingEndPointEvent.getCallSource();
incomingCall.accept();
+---


** Reject call

	To reject the call, we use the method <<<reject()>>> of the class <<<SipCall>>>.
	
+---
this.pendingEndPointEvent = event;
incomingCall = pendingEndPointEvent.getCallSource();
incomingCall.reject();
+---
	
* Finish call

	Once the call is established can be finished using the object <<<SipCall>>> that are set when you called:
	
+---
currentCall.hangup();
+---

User Plane
	
	With Plane User can define and build a network of media distribution that is associated with a call. For this you must configure the media, configure the components to connect to multimedia devices to the network and these to perform transmission and reception of audio and video.

* Initialization media

	Initialization of media requires prior configuration is made from a series of parameters that are used to create a <<<MediaSession>>> with a certain characteristics. We use the method <<<createMediaSession()>>> from the factory <<MSControlFactory>> as mentioned above in the initialization section of Control Plane.

	This <<<MediaSession>>> be used in <<<UaFactory>>> to create a <<<ua>>> which internally create a <<<NetworkConnection>>> based on the previous configuration.

	Initialization of media itself takes place once the call, which determines the final characteristics of audio and video. It initializes the internal media stack that is responsible for all management and encoding, sending over the network ... all managed by the <<<NetworkConnection>>> created internally by the SIP stack.

	As mentioned in a previous section, we know that the call has been set correctly because it has received an event <<<SipCallEvent.CALL_SETUP>>>, through which we can access the <<<NetworkConnection>>> that are obtained after the call:

+---
SipCall currentCall = event.getSource();
currentCall.getNetworkConnection(null);
+---
	and direction of each media stream, ie for each stream media if is SENDONLY, RECVONLY o SENDRECV:

+---
currentCall.getMediaTypesModes();
+---

	From each stream direction can create particular media components (using the <<<MediaSession>>> created in the configuration) that is connected to <<<NetworConnection>>> obtained, specifically the audio stream or video of the latter.

	Finally, with the established call is the time to establish media streams (audio and video). This will be created for each media component to be objects of class <<<MediaComponentAndroid>>>.
	
* {Audio Components}

 	You must create audio components for both the emission and reception. To create the audio components will use a method of <<<MediaSessionAndroid>>>.

		** <<<createMediaComponent>>>, we indicate the type of component you need, if emission or reception, as well as the speaker for which we receive.
		 
			* A receiving component and audio plays through the external speaker:

+---
Parameters params = new ParametersImpl();
params.put(MediaComponentAndroid.STREAM_TYPE, AudioManager.STREAM_MUSIC);
audioRecorderComponent = mediaSession.createMediaComponent(
	MediaComponentAndroid.AUDIO_RECORDER, 
	params);
+---	

			* An audio output component:
			
+---
audioPlayerComponent = mediaSession.createMediaComponent(
	MediaComponentAndroid.AUDIO_PLAYER,
	Parameters.NO_PARAMETER);
+---

	* Once you've created the audio components, we must define each component as it will, if of emission or reception and make them start. We will need access to the configuration <<<NetworkConnection>>> to retrieve the type of <<<stream>>> we want to play, in this case will be <<<StreamType.audio>>>.
	 
		* Audio receiver component.

+---
audioRecorderComponent.join(Direction.RECV, nc.getJoinableStream(StreamType.audio));
audioRecorderComponent.start();
+---

		* Audio output component.
		
+---
audioPlayerComponent.join(Direction.SEND, nc.getJoinableStream(StreamType.audio));
audioPlayerComponent.start();
+---

	To stop the audio components:
	
+---
audioRecorderComponent.stop();
audioPlayerComponent.stop();
+---

* {Video compoments}

	The creation of the media components are very similar to the audio. It also uses a method of <<<MediaSessionAndroid>>>. In this case we add some parameters like <<SurfaceView>> (is the surface where it will display video received), the width and length of the device's screen. We will need access to the configuration <<<NetworkConnection>>> to retrieve the type of <<<stream>>> we want to play, in this case will be <<<StreamType.video>>>.
	
	* Video receiver component, adding the <<SurfaceView>>, height and width of the screen of the device:

+---
DisplayMetrics dm = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(dm);
int Orientation = getWindowManager().getDefaultDisplay().getOrientation();

Parameters params = new ParametersImpl();
params.put(MediaComponentAndroid.VIEW_SURFACE,
		(View) findViewById(R.id.video_receive_surface));
params.put(MediaComponentAndroid.DISPLAY_WIDTH, dm.widthPixels);
params.put(MediaComponentAndroid.DISPLAY_HEIGHT,
		dm.heightPixels);
videoRecorderComponent = mediaSession.createMediaComponent(
		MediaComponentAndroid.VIDEO_RECORDER, params);
+---

	* Video output component, adding the <<SurfaceView>> and the orientation of the device:

+---
Parameters params = new ParametersImpl();
params.put(MediaComponentAndroid.PREVIEW_SURFACE,
		(View) findViewById(R.id.video_capture_surface));
params.put(MediaComponentAndroid.DISPLAY_ORIENTATION,
		Orientation);
videoPlayerComponent = mediaSession.createMediaComponent(
		MediaComponentAndroid.VIDEO_PLAYER, params);
+---

	Once the component has been set correctly, we can define what is and what action we want to do:
	
		* Video receiver component:

+---
videoRecorderComponent.join(Direction.RECV, nc.getJoinableStream(StreamType.video));
videoRecorderComponent.start();
+---

		* Video output component:
	
+---
videoPlayerComponent.join(Direction.SEND, nc.getJoinableStream(StreamType.video));
videoPlayerComponent.start();
+---	

	To stop the video components:

+---
videoRecorderComponent.stop();
videoPlayerComponent.stop();
+---


Creating an Android application

	From this section will give some recommendations and next steps to perform an Android application that incorporates Kurento Android SDK. They discussed issues such as configuration files .xml, activities and services required, managing preferences, and finally, how to manage the media, both audio and video.

	In the final section you can find some code examples to follow.

	The next diagram you can see a diagram of the activities, services and components that are necessary for an application.

[images/diagrama-tk-softphone.png]

* Configuration file {AndroidManifest.xml}
	
	Configuration file AndroidManifest.xml of an application based on Android is very important, because in this file are located, the permissions the user must agree to when installing the application, and other activities and services which shall be composed of the application.
	
		Some of the necessary permissions are:

+---
<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
<uses-permission android:name="android.permission.CAMERA"></uses-permission>
<uses-permission android:name="android.permission.RECORD_AUDIO"></uses-permission>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
<uses-permission android:name="android.permission.INTERNET"></uses-permission\>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<uses-permission android:name="android.permission.READ_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.WRITE_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission>
+---
			
		Depending on the application wants to implement some of these permits are not necessary. For all permissions that are available can be found in the {{{http://developer.android.com/reference/android/Manifest.permission.html}guía de desarrollo de Android}}.
		
		Also define the activities and services that make up our application, such as:
		
			* A service is defined as:
			
+--- 
<service android:enabled="true" android:name="com.tikal.softphone.SoftPhoneService" \>
+---

			* An activity is defined as:
			
+---			
<activity android:name="com.tikal.videocall.VideoCall" android:label="Video Call" 
android:theme="@android:style/Theme.NoTitleBar.Fullscreen" android:screenOrientation="landscape" 
android:launchMode="singleTop" \>
+---
				
		Each of the activities that will be launched within the application should be defined in this file. For more information on setting AndroidManifest.xml file can be found in the  {{{http://developer.android.com/guide/topics/manifest/manifest-intro.html}guía de desarrollo de Android}}.

		Por último, en la configuración de la actividad principal deberá incluirse un apartado llamado <<{{{http://developer.android.com/guide/topics/manifest/intent-filter-element.html}intent-filter}}>> que nos servirá para cuando un usuario quiera realizar una llamada desde los contactos según el "scheme" que nosotros elijamos, en este caso se busca qué cuando un usuario tenga guardado un contacto con datos como <<<"sip:juan@server.net">>> se abra nuestra actividad:
		
+---
<intent-filter>
	<action android:name="android.intent.action.SENDTO" \>
	<category android:name="android.intent.category.DEFAULT" \>
	<data android:scheme="sip" \>
	<data android:scheme="imto" \>
<\intent-filter> 
+---	
	
* Activities

	** {{Principal activity}}
	
	** Management Connection Preferences
	
	** Management Media Preferences
	
	** Management receiving a call
	
	** Management emission a call
	
	** Management media (Video and Audio)


* Services

	** {{Principal service}}
	
	** {{Service to an active call}}


* Controller

	There should be a class that must implement some interfaces: <<<SipEndPointListener, SipCallListener, CallNotifier and InterfacePhone>>>. This class might be called <<"controller">>. It will be responsible for controlling and managing all the events SIP we can get  or we can send. Also, you must implement the normal behavior of a phone as a call to accept, reject, etc ... This class will notify the listener to subscribe.

** SipEndPointListener

	As explained in the Control Plane, implementing this interface will be able to receive some events and the application should behave as expected of her:

		* <<<INCOMING_CALL>>>, this event means that someone is making a call, so from the class <<controller>> have to notify the <<<listener>>> you have added a call is coming. In this case you must invoke a method on an object of the interface <<<CallListener>>>, which we shall discuss in the {{Principal Service}} who shall implement this interface, called <<<incomingCall (String uri )>>>. Basically what we will do is start the activity responsible for receiving calls.
	
		* <<<REGISTER_USER_SUCESSFUL>>>, this event means that the register with the connection settings are correct and have been checking on the server. In this case as in the previous one, is a method of an interface object <<<CallListener>>> who will have to invoke, called <<<registerUserSucessful()>>>. This method is responsible for sending the user to know that your registration application has been successful.

		* <<<REGISTER_USER_FAIL>>>, this event signifies that registration was incorrect. The method will be called <<<registerUserFailed()>>> and be responsible for sending the user to know that your registration application has been wrong.
	

** SipCallListener

	The implementation of this method in the class <<controller>> should be able to handle the next events, as in the previous section, the method call will be an object of the interface <<<CallListener>>> that will be implemented by the {{Principal Service}}:

	* <<<CALL_SETUP>>>, this event means that the call has been established and can close the activity responsible for monitoring or issuing calls or receiving calls and start the activity and service that will manage the media, both video audio. This will be done by calling <<<callSetup(NetworkConnection networkConnection)>>>.

	* <<<CALL_TERMINATE>>>, this event means that the call has been terminated by any of the users, so will have to stop the service and activity that is responsible for managing a call. This will be done by calling <<<callTerminate()>>>.
	
	* <<<CALL_REJECT>>>, this event means that the call has been rejected by the contact, so you have to close the activity manages the outbound. This will be done by calling <<<callReject()>>>.
		
 
** InterfacePhone 

	This interface represents the basic actions of a phone:
	
		* <<<aceptCall()>>>. Accept an incoming call.

		* <<<reject()>>>. Reject an incoming call.

		* <<<call(String remoteURI)>>>. Making an outgoing call to a contact.

		* <<<hang()>>>. Hang up a call.

*** <<<aceptCall()>>>
	
	This method be called from the activity that is responsible for management of incoming calls. The implementation of this method must collect call data and call the <<<accept()>>> of the class <<<SipCall>>>.  In this way is sent via the SIP call has been accepted.

*** <<<reject()>>>

	This method  be called from the activity that is responsible for management of incoming calls. The implementation of this method must collect call data and call the method <<<reject()>>> of the class <<<SipCall>>>. This will be sent using the SIP call has been rejected.


*** <<<call(String remoteURI)>>>

	This method is called from the main activity of the application or from the activity that is responsible for managing outbound calls from a contact. You must be at the Uri parameter of the contact you want to make the call. In implementing this method, you use an object of class <<<SipEndPoint>>>, which will be defined in the user register (be seen in the section where registered users), using the method <<<dial (String remoteParty, Direction direction, SipCallListener callController)>>> which will send through the SIP invitation message.

*** <<<hang()>>>

	This method is called from the activity that handles a call. The implementation of this method will use an object of class <<SipCall>> to call your method <<<hang()>>> in this way using the SIP protocol you can send the call completion message.


** CallNotifier

	This interface represents two methods to add or delete <<listener>> interface type <<<CallListener>>>, as mentioned above will be implemented in the {{Principal Service}}:
	
		* <<<addListener(CallListener listener)>>>. Add a <<listener>>.

		*<<<removeListener(CallListener listener)>>>. Delete a <<listener>>.


{Principal activity}

	This will be the activity that opens when you start the application, must be responsible for:
	
	* To configure the connection and media preferences.

	* Start the service.

	* Make calls.

	* Access to contacts.

	* Others...

* File XML

	This activity will have its own file <<<xml>>> which is defined as the user interface. This interface should have at least:

		** A <<<EditText>>> to write the <<<uri>>> of the person you wish to call.

		** A <<<Button>>> to access the contacts.

		** A <<<Button>>> to access the call history

* onCreate

	When you create an activity of the important steps that must be carried out is to check if the device has any active network, since for all SIP transactions is necessary. As it is, it should display an error message to the user and close the application before proceeding. If the device has any active network, then we can move forward.

	The activity will subscribe to the message delivery will perform the {{Princial Service}} in order to receive messages that arrive when the activity is in the foreground or background.

	Once we have done testing the network, it must collect data on preferences to configure the data required for registration to the SIP server (user, domain, server, port). It also collects information on the configuration of the media. If the collection of these data are correct, we proceed to attempt to register against the server set in preferences. According to the registration is successful or not, it will call the corresponding functions to send messages with the {{Principal service}}.

* onNewIntent

	As seen in the setup {{AndroidManifest.xml}}, how to launch an application can be <<<launchMode>>>. When configured in this way, you must implement this method, <<<onNewIntent>>>. This means that if there is an already created, not recreate it go directly to this method. In this part, you should check again if the network is active.

* onResume

	In this part of the application we first, subscribe to changes in network status that offers Android, thanks to this we can monitor changes occurring within the device's network interfaces and so act accordingly as explained in network control.

	Furthermore, we have the control over the buttons that are defined in the file <<<xml>>> interface configuration.

* Contacts

	When we opened the access  contacts activity and select a contact, to return to the activity in the section <<<onActivityResult>>>  be checked using the kind of help to get data from the agenda if the selected contact has set a <<<uri>>> correct. If so, the call is made.
	
* {Network control}

	It is important for these applications to be aware of changes in existing network interfaces in order to have control of changing ip's, network outages, change to 3G WIFI,  ... Therefore, as mentioned before the main activity will subscribe to the changes that exist in this section of the device.

	Recommended steps to follow are:
		
		** Save the interface type being used, WiFi or 3G. This will help us determine first whether we have any active network interfaces or not.

		** We must know whether the IP we were using is the same or changed. This is important because, although we are on the same interface IP changed if we need to re-register the server so that we can be reached without problems.

		** Finally, if you change the network interface or IP address of our device we finish our <<controller>> using the method <<<finishUA()>>>,  delete the data that exist in {{<<< ApplicationContext>>>}} and also to the main service. Once done, we will re-create the <<controller>> with the new configuration data, fill {{<<<ApplicationContext>>>}} with the necessary data and attempt to register again.

* Message Control

	The application must also subscribe to receive messages from the principal service. Since the service will send messages to the activity and that the registration was successful, erroneous or to have accepted the call and must close the outbound activity.


* Management receiving a call

	Only we can make a call when we have an address <<<uri>>> to be able to call. When you call, you will have to start the activity that is responsible for managing the emission calls. It is advisable to add them as parameters to this activity, the <<id>> the user that we have collected from the agenda and the <<<uri>>> the contact you want to call. Will the new activity ultimately responsible for carrying the call.

* Menu

	To access the application preferences should have a menu from which you can access them. In these menus you should also add a clause to exit the application.

* Application termination
	
	To finish,  you must:

	** Stop listening to network changes that exist in the device.

	** Stop the <<controller>> using the method <<<finishUA>>>.
	
	** Releasing the data stored in {{<<<ApplicationContext>>>.}}

	** Finish the principal service.

{Services}

	The creation of services is needed to control some events that can occur when the application is not in the foreground. This should create two services, one that handles all events of the SIP connection and another to manage the media during a call.

* {Principal service}

	The principal application service will be responsible for handling events that may arise from SIP, therefore, is responsible for implementing the interface <<<CallListener>>>.

	Some of the responsibilities that will have this service are:

	* When you start the service, you should start the notification that the application is open in the notification bar. At the time of creating the notification should be the main activity associated with this notification.

	* Added using the method <<<addListener()>>> object <<controller>>, which will recover thanks to {{<<<ApplicationContext>>>}} in order to receive events. In this way from <<controller>> can call our implementation of <<<CallListener>>>.

	* When we receive a call to <<<incomingCall(String uri)>>>, the activity should be initiated to manage the incoming call. In this way it will be the user who may accept or reject the call. On the other hand, because we are using a service, each time this method is invoked and if the application is in the background make it up this activity.

	* When we receive a call to <<<registerUserSucessful()>>> then it should be the principal activity with a message that the user is properly registered so that it can notify the user via a message.

	* When we receive a call to <<<registerUserFailed()>>> then it should be the main activity with a message that the user <<no>> correctly registered so that it can notify the user via a message.

	* When we receive a call to <<<callSetup(NetworkConnection networkConnection)>>> then it should be the main activity by a message that should stop the activity of issuing calls or receive calls as appropriate. Furthermore, you must start the service for a call.

	* When we receive a call to <<<callTerminate()>>>,you must stop the service for a call.

	* When we receive a call to <<<callReject()>>> then it should be the main activity by a message that should stop the activity responsible for outbound calls, as only we can reject a call when we perform.

	* Finally, when the application is finished the service will be in charge to eliminate the notification of the notification bar and also close the service.

	
**{CallListener}

	This interface represents the events that we receive from SIP:
	
		* <<<incomingCall(String uri)>>>. Call this method from <<controller>> when we receive an invitation to call.

		* <<<registerUserSucessful()>>>. Call this method from <<controller>>  when the user is successfully registered.

		* <<<registerUserFailed()>>>. Call this method from <<controller>>  when the user <<no>> is registered correctly.

		* <<<callSetup(NetworkConnection networkConnection)>>>. Call this method from <<controller>>  when the call is successfully established by the users.

		* <<<callTerminate()>>>. Call this method from <<controller>> when the call is completed.

		* <<<callReject()>>>.  Call this method from <<controller>> when the call has been rejected.

* {Service to an active call}

	This service will be responsible for managing an active call and will be created from the principal service when a call is set correctly.

	* When you create the service, one of the first steps to be done is to change the notification that we have in the notification bar to indicate that we have an active call, so if we go to the main menu or agenda, etc ... we can return the call without problems. Notification shall be associated with the activity that is responsible for displaying the media in the device.

	* During the creation of the service, also create audio components for both the emission and reception. The video components were created in the activity responsible for displaying the media in the device, this is  for sending audio to continue if the application is in the background, but no video.

	* When the service has began, and created the audio components properly, we must define each component as it will, if emission or reception and make them start.

	* When the audio components have started, you must start the activity will show the media in the device, then create your video components.

	* When the service is destroyed, it must:

		** Change the notification of the notification bar on the main notice.

		** Stop the audio components.

		** Tell the activity that is responsible for displaying the media in the device should be closed.

Management preferences

* {Connection}

	In the connection preferences should allow setting the following:
	
	** <<User>>:  User registration.

	** <<Password>>: Password user registration.

	** <<Domain>>: Domain user registration.

	** <<Ip Server SIP>>: Server IP  where registered users.

	** <<Port Server SIP>>: Server Port  where registered users.

* {Media}

	In the preferences of media should leave the following data set:

	* <<Maximum BandWidth>>: Indicate the max bandwidth will be used in bps(bits per second).

	* <<Video codec>>: Indicate the video codecs supported.

		* H263

		* MPEG4

	* <<Frame size>>: Indicate the frame size in pixels (width x height)

	* <<Call direction>>: Indicate the mode of each media stream.

	* <<Maximum frame rate>>: Indicate the max frame rate will be used.

	* <<Gop size>>:Indicate the max number of frames in a group of pictures, or 0 for intra_only.

	* <<Queue size>>: Indicate the number of frames will be buffered from the camera.

	* <<Audio Codec>>: Indicate the audio codecs supported.

			* AMR

			* MP2
		
	* <<Call direction>>: Indicate the mode of each media stream.
		
Management receiving and emission a call

	For both emission and reception of calls we have two activities that represent us that a contact is calling us or that we are calling us.

* Management emission

	The activity responsible for the issuance of calls will be created when a contact is chosen or known to contact you want to make the call and the display should show at least:
	
		** The name of the contact.

		** The picture of the contact, if he had.

		** A button to cancel the call.

	This activity should only show the interface for the user know you are in a call and you can cancel it. The completion of the call will class <<controller>> we have defined above.

	The closure of this activity can come from three circumstances:

		** Contact reject the call.

		** The contact accepts the call.

		** The user cancels the call.


* Management receiving

	The activity responsible for receiving calls will be created from the service control manager can get SIP events, such as an <invite> in the case of a call reception. The interface of this activity on the screen should show at least:

		** The name of the contact.

		** The picture of the contact, if he had.

		** A button to accept the call. When pressed, they must notify <<controller>> that the call has been accepted and close the activity.

		** A button to cancel the call. When pressed, they must notify <<controller>> that the call has been rejected and close the activity.

		** Vibrate. When you accept or reject the call by the vibration will stop.

	The closure of this activity can come from three circumstances:

		** Anyone who calls you, cancel the call.

		** The call is rejected.

		** We accept the call.
	

Management media (Video and Audio){Gestión del media} (Vídeo y Audio)

	The video and audio management are separated. The reason they are separated is basically that we can continue with a discussion of whether the application is in the foreground or not. Thus, the audio is handled in the service responsible for active calls and video are handled in the activity will show the media in the device, this is so not send or receive video when the device is not going to show and so do not saturate it.

* {Activity}

	This activity will be in charge of showing the media in the device and play audio through the speakers and pick up the audio we generate. This activity will have its own definition in a file <<<xml>>>, which will show the interface elements should be at least:

		* A <<<SurfaceView>>> to display the video received.

		* A <<<SurfaceView>>> to display the video that we sent.

		* A <<<Button>>> to hang up the call.

	We can add two more buttons for:

		* Manage the mute during a conversation.

		* Manage the speaker for which we want to play the audio.

	
	The creation of this activity lies in that a call has been set correctly, and the service responsible for managing active calls has been launched. The service for its part has already been responsible for managing the audio components on the other hand, as explained above. This activity will be the one responsible for managing the video components to this when creating each component should be established by associating each to his <<<SurfaceView>>> corresponding.

	Once the activity is already active, you must boot these video components to start broadcasting and receiving video and can display in each of the <<<SurfaceView>>>. As discussed above, we have several buttons to manage different aspects of the conversation.

	* If we wanted to end the call would use the button made ​​for them. To end the call using the object <<controller>>, which will recover thanks to <<<ApplicationContext>>>, using the method <<<hang()>>>. And end of the activity to end the call.

	* If we wanted to add or remove the mute button will use the conversation made ​​for them. To do this we must stop or re-boot the audio component, which also recovered thanks to <<<ApplicationContext>>>. Before we started and stopped what he was doing that component.

+---
if (audioPlayerComponent.isStarted())
	audioPlayerComponent.stop();
else
	audioPlayerComponent.start();
+---

	* We have the option to change the loudspeaker which reproduces the audio. Recover the audio component by <<<ApplicationContext>>> and we would define the type of audio component is and the speaker for which you want to play.

+---
if (audioRecorderComponent != null) {
	audioRecorderComponent.stop();
	audioRecorderComponent.unjoin(nc
			.getJoinableStream(StreamType.audio));
}

Parameters params = new ParametersImpl();
params.put(MediaComponentAndroid.STREAM_TYPE,
		AudioManager.STREAM_VOICE_CALL);
audioRecorderComponent = mediaSession
		.createMediaComponent(
				MediaComponentAndroid.AUDIO_RECORDER,
				params);

if (audioRecorderComponent != null) {
	audioRecorderComponent.join(Direction.RECV,
			nc.getJoinableStream(StreamType.audio));
	audioRecorderComponent.start();
}
+---

	* Because there is a service that manages the call, if at any time the user logs out of this activity as one who "lose" the video would be, since the activity when it comes to <<pause>> components must stop not congest video for the device. Also do not make sense to continue sending or receiving video when not viewed.

	* When we return to the activity due to the notification of the notification bar, video components must be re-created and in order to return to receive and transmit video.

	* Finally, when the activity ends, either because the button is pressed to end the call or because we have received the message from the service they have hung on the other hand, we must stop the video components.

* {Video}

	The creation of video components can be seen in the section on User Plane.

* {Audio}

	The creation of audio components can be seen in the section on User Plane.

Other classes of help

	These classes listed below are classes that can be created to facilitate the task of developing some of the features that may have application.

* {ApplicationContext}

	This class will be useful to share some information among all the activities and not lose information when the activity is in the background. Simply be a hash table in which we will be storing and collecting data as needed.

+---
public static HashMap<String, Object> contextTable = new HashMap<String, Object>();
+---

	From any part of the application can do:

	** ApplicationContext.contextTable.put("key", object), to store any type of object that we need at any time.

+---
ApplicationContext.contextTable.put("controller", controller);
+---
	** ApplicationContext.contextTable.get(objeto), to collect any type of object that we stored earlier. We will make the object which is casting.
+---
controller = (Controller) ApplicationContext.contextTable.get("controller");
+---
	

* Get the current ip

	Collect ip Android device in many applications is something that may be needed very often, so it is recommended that a small class to help us with this task. An example of the function would be:

+---
public static InetAddress getLocalAddress() {
	try {
		for (Enumeration<NetworkInterface> en = NetworkInterface
				.getNetworkInterfaces(); en.hasMoreElements();) {
			NetworkInterface intf = en.nextElement();
			for (Enumeration<InetAddress> enumIpAddr = intf
					.getInetAddresses(); enumIpAddr.hasMoreElements();) {
				InetAddress inetAddress = enumIpAddr.nextElement();
				if (!inetAddress.isLoopbackAddress()
						&& (inetAddress instanceof Inet4Address)) {
					return inetAddress;
				}
			}
		}
	} catch (SocketException e) {
		e.printStackTrace();
	}
	return null;
}
+---


* Get the contact details of the agenda

	For contact information, you should create a class to take care of it from the uri of the user. In this way, we may collect the name, photo, music associated with that contact.

	We query:

		* <<<getName(Integer Id)>>> where to get the contact's name as its identifier within the contacts. This will help us when we choose a contact from your contacts access to the application.

		* <<<getName(Intent data)>>> where to get the contact's name after choosing the contact directly from the agenda without going through the application.

		* <<<getId(String sipUri)>>> where to get the id of the contact in the phonebook from your SIP ID.

		* <<<getId(Intent data)>>> where we get the id of the contact in the phonebook.

		* <<<getSip(Intent data)>>> where we get the SIP identifier after selecting the contact directly from the agenda without going through the application.

		* <<<getPhoto(Integer id)>>> where to get the contact picture, if available.

Examples

* AndroidManifest.xml

	In this section we define:

		* The version of the application.

		* Where we want to install (in this case the memory card if possible).

		* The main application package.

+---
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	package="kas.softphone" android:versionCode="1"
	android:versionName="1.0" android:installLocation="preferExternal">
+---
	
	We define the icon and application name.

+---
<application android:icon="@drawable/icon" android:label="@string/app_name">
+---

	We define the main activity:

		* The name of the activity (SoftPhone).

		* The way to launch the activity (singleTask).

		* The <<intent-filter>> that have:

			** Main activity (android.intent.action.MAIN)

			** Start the activity from your contacts whenever you press one of them which has stored data <<<sip:xxx@xxxx.xxx>>>.
+---
<activity android:name="SoftPhone" android:label="@string/app_name"
	android:launchMode="singleTask">
	<intent-filter>
		<action android:name="android.intent.action.MAIN" />
		<category android:name="android.intent.category.LAUNCHER" />
	</intent-filter>

	<intent-filter>
		<action android:name="android.intent.action.SENDTO" />
		<category android:name="android.intent.category.DEFAULT" />
		<data android:scheme="sip" />
		<data android:scheme="imto" />
	</intent-filter>
</activity>
+---

	Definition of emission management activities and receiving calls.

+---
<activity android:name="com.tikal.media.MediaControlIncoming"
	android:label="Media Control Incoming">
</activity>
<activity android:name="com.tikal.media.MediaControlOutgoing"
	android:label="Media Control Outgoing">
</activity>
+---

	Defining the activity displayed by the media in the device. It adds a parameter to clear the notification bar and is full screen (<<<android:theme="@android:style\/Theme.NoTitleBar.Fullscreen">>>). In addition, it undertakes to be always horizontal orientation (<<<android:screenOrientation="landscape">>>).

+---
<activity android:name="com.tikal.videocall.VideoCall"
	android:label="Video Call" android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
	android:screenOrientation="landscape" android:launchMode="singleTop" >
</activity>
+---

	Defining preferences management activities. In this case the orientation is vertical.

+---
<activity android:name="com.tikal.preferences.Connection_Preferences"
	android:label="Connection Preferences" android:screenOrientation="portrait">
</activity>

<activity android:name="com.tikal.preferences.Video_Preferences"
	android:label="Video Preferences" android:screenOrientation="portrait">
</activity>
+---

	Definition of services you will need the application.

+---
<service android:enabled="true"
	android:name="kas.softphone.SoftPhoneService" />
<service android:enabled="true"
	android:name="kas.videocall.VideoCallService" />
+---

	Definition:

		* Minimum version of the operating system must have the device (<<<uses-sdk android:minSdkVersion="8">>>).

		* Hardware and software dependencies (<<<uses-feature android:name="android.hardware.camera">>>).

		* Permits must accept the user (<<<uses-permission android:name="android.permission.CAMERA">>>).

+---
<uses-sdk android:minSdkVersion="8" />

<uses-feature android:name="android.hardware.camera"></uses-feature>
<uses-feature android:name="android.hardware.camera" android:required="false" />
<uses-feature android:name="android.hardware.camera.front" android:required="false" />
<uses-feature android:name="android.hardware.camera.autofocus"></uses-feature>

<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
<uses-permission android:name="android.permission.CAMERA"></uses-permission>
<uses-permission android:name="android.permission.RECORD_AUDIO"></uses-permission>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<uses-permission android:name="android.permission.READ_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.WRITE_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission>
+---
	
* The application

	Subscription to the main service message when you create the activity. In this way we are saying we will have a method <<<update>>> in which processes incoming messages from the main service.

+---
SoftPhoneService.setUpdateListener(this);
+---

+---
@Override
public void update(Message message) {
	 if (message.getData().containsKey("Register")) {
		if (message.getData().getString("Register").equals("Sucessful")) {
			registerSucessful();
		} else if (message.getData().getString("Register").equals("Failed")) {
			registerFailed();
		}
	} else if (message.getData().containsKey("finishActivity")) {
		if (message.getData().getString("finishActivity").equals("MEDIA_CONTROL_OUTGOING")) {
			finishActivity(MEDIA_CONTROL_OUTGOING);
		}
	}
}
+---

	When you receive one of these messages, methods should be as follows to give a warning to the user.

+---
public void registerSucessful() {
	SoftPhone.this.text = (TextView) findViewById(R.id.textRegister);
	SoftPhone.this.text.setTextSize(20);
	SoftPhone.this.text.setTextColor(Color.GREEN);
	SoftPhone.this.text.setText("Register Sucessful");

	isRegister = true;
	ApplicationContext.contextTable.put("isRegister", isRegister);
}
+---

	Subscription to the changes that may exist in the device connections. After subscribing you have to implement a new <<<PhoneStateListener>>> and in the method <<<onDataConnectionStateChanged>>>. The steps of this method are explained in the Network Control section.

+---
signalManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
signalManager.listen(signalListener,	PhoneStateListener.LISTEN_DATA_CONNECTION_STATE);
+---

+---
private final PhoneStateListener signalListener = new PhoneStateListener() {
	public void onDataConnectionStateChanged(int state) {
		if (!isExit) {
			ConnectivityManager ConnectManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);

			String sNetworkType = "No Activate";
			/*
			 * Control para sólo transmitir cuando tengamos conexión si es
			 */
			boolean backgroundEnabled = ConnectManager.getBackgroundDataSetting();
			int networkType = -1;
			NetworkInfo activeNetwork = ConnectManager.getActiveNetworkInfo();
			if (activeNetwork != null) {
				networkType = activeNetwork.getType();
			}
			boolean isAddressEqual = false;
			boolean isNetworking = false;
			InetAddress lAddressNew;
			InetAddress lAddress;

			switch (networkType) {
			case ConnectivityManager.TYPE_WIFI: 
				lAddressNew = NetworkIP.getLocalAddress();
				lAddress = (InetAddress) ApplicationContext.contextTable.get("localAddress");
				if (lAddress != null)
					if (lAddressNew.equals(lAddress))
						isAddressEqual = true;
					else
						isAddressEqual = false;
				isNetworking = true;
				break;
			case ConnectivityManager.TYPE_MOBILE: 
				ApplicationContext.contextTable.put("isNetworking", true);
				lAddressNew = NetworkIP.getLocalAddress();
				lAddress = (InetAddress) ApplicationContext.contextTable.get("localAddress");
				if (lAddress != null)
					if (lAddressNew.equals(lAddress))
						isAddressEqual = true;
					else
						isAddressEqual = false;
				isNetworking = true;
				break;
			case -1: // Disconneted
				isNetworking = false;
				break;
			default:
				break;
			}

			if (isNetworking) {
				if (!isAddressEqual) {
					controller = null;
					isRegister = false;
					ApplicationContext.contextTable.put("isRegister", isRegister);

					intentService = (Intent) ApplicationContext.contextTable.get("intentService");
					try {
						stopService(intentService);
					} catch (Exception e) {
						Log.e(LOG_TAG, "stopService " + e.getMessage()
								+ "; " + e.toString());
					}
					ApplicationContext.contextTable.clear();
					if (initControllerUAFromSettings()) {
						register();
					}
				}
			} else {
				try {
					if ((Boolean) ApplicationContext.contextTable.get("isRegister")) {
						if (controller != null)
							try {
								controller.finishUA();
								controller = null;
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						isRegister = false;
						ApplicationContext.contextTable.put("isRegister", isRegister);
						intentService = (Intent) ApplicationContext.contextTable.get("intentService");
						try {
							stopService(intentService);
						} catch (Exception e) {
							Log.e(LOG_TAG, "stopService " + e.getMessage()
									+ "; " + e.toString());
						}
						ApplicationContext.contextTable.clear();
					}
				} catch (Exception e) {

				}
			}
		}
	}
};
+---

	Initialize the values ​​needed to use the method <<<initUA>>> of <<controller>>. This method will return <<<true>>> If all initialization has been properly and we have a network interface up. If we have no active network interface will return <<<false>>> In addition to exit the activity and show a message to the user.

+---
private boolean initControllerUAFromSettings() {
	try {
		SharedPreferences settings = PreferenceManager
				.getDefaultSharedPreferences(getBaseContext());
		localUser = settings.getString("LOCAL_USERNAME", "android1");
		localRealm = settings.getString("LOCAL_DOMAIN", "urjc.es");
		proxyIP = settings.getString("PROXY_IP", "193.147.51.17");
		proxyPort = Integer.parseInt(settings.getString("PROXY_PORT",
				"5060"));

		this.textUser = (TextView) findViewById(R.id.textUser);
		this.textUser.setText("User: " + localUser + "@" + localRealm);

		this.textServer = (TextView) findViewById(R.id.textServer);
		this.textServer.setText("Server: " + proxyIP + ":" + proxyPort);

		ni = connManager.getActiveNetworkInfo();
		String conType = ni.getTypeName();

		if ("WIFI".equalsIgnoreCase(conType))
			connectionType = ConnectionType.WIFI;
		else if ("MOBILE".equalsIgnoreCase(conType))
			connectionType = ConnectionType.MOBILE;

		this.audioCodecs = getAudioCodecsFromSettings();
		this.videoCodecs = getVideoCodecsFromSettings();
		this.localAddress = NetworkIP.getLocalAddress();
		ApplicationContext.contextTable.put("localAddress", localAddress);
		return true;
	} catch (Exception e) {
		Toast.makeText(SoftPhone.this,
				"SoftPhone: Please enable any network interface.",
				Toast.LENGTH_SHORT).show();

		finish();
		return false;
	}

}
+---

	Collect data from media preferences.

+---
private ArrayList<VideoCodecType> getVideoCodecsFromSettings() {
	SharedPreferences settings = PreferenceManager
			.getDefaultSharedPreferences(getBaseContext());

	ArrayList<VideoCodecType> selectedVideoCodecs = new ArrayList<VideoCodecType>();
	if (settings.getBoolean("H263_CODEC", false))
		selectedVideoCodecs.add(VideoCodecType.H263);
	if (settings.getBoolean("MPEG4_CODEC", false))
		selectedVideoCodecs.add(VideoCodecType.MPEG4);
	if (settings.getBoolean("H264_CODEC", false))
		selectedVideoCodecs.add(VideoCodecType.H264);

	return selectedVideoCodecs;
}

private ArrayList<AudioCodecType> getAudioCodecsFromSettings() {
	SharedPreferences settings = PreferenceManager
			.getDefaultSharedPreferences(getBaseContext());

	ArrayList<AudioCodecType> selectedAudioCodecs = new ArrayList<AudioCodecType>();
	if (settings.getBoolean("AMR_AUDIO_CODEC", false))
		selectedAudioCodecs.add(AudioCodecType.AMR);
	if (settings.getBoolean("MP2_AUDIO_CODEC", false))
		selectedAudioCodecs.add(AudioCodecType.MP2);
	if (settings.getBoolean("AAC_AUDIO_CODEC", false))
		selectedAudioCodecs.add(AudioCodecType.AAC);

	return selectedAudioCodecs;
}
+---

	Once the necessary variables are initialized make a register and start the principal service.

+---
private void register() {
	if (controller == null)
		controller = new Controller();
	intentService = (Intent) ApplicationContext.contextTable.get("intentService");
	if (intentService == null) {
		intentService = new Intent(this, SoftPhoneService.class);
		ApplicationContext.contextTable.put("intentService", intentService);
		startService(intentService);
	}

	if (initControllerUAFromSettings())
		initUA();
}
+---

	In the method <<<register>>> appears the call to <<<initUA>>> which finally made ​​the call to <<<initUA>>> of <<controller>>. Where it really make the registration and initialization of structures to SIP.

+---
private void initUA() {
	try {
		controller.initUA(audioCodecs, videoCodecs, localAddress,
				connectionType, proxyIP, proxyPort, localUser, localRealm);
		ApplicationContext.contextTable.put("controller", controller);
	} catch (Exception e) {
		e.printStackTrace();
	}
}
+---

	Make a call to a contact.

		* Using the button to access the contacts.

+---
final Button buttonContacts = (Button) findViewById(R.id.contacts);
	buttonContacts.setOnClickListener(new OnClickListener() {

		@Override
		public void onClick(View v) {
			try {
				openContacts();
			} catch (Exception e) {
				Log.e("Error Search", e.toString());
			}
		}
	});
private void openContacts() {
	Intent intentContacts = new Intent(Intent.ACTION_PICK, 	ContactsContract.Contacts.CONTENT_URI);
	startActivityForResult(intentContacts, PICK_CONTACT_REQUEST);
}
+---	

		And within <<<onActivityResult(int requestCode, Intent resultCode, data) int>>> we have:

+---
if (requestCode == PICK_CONTACT_REQUEST) {
	if (resultCode == RESULT_OK) {
		Integer id = null;
		String sip = null;
		String name = null;

		id = controlcontacts.getId(data);
		sip = controlcontacts.getSip(data);
		name = controlcontacts.getName(data);

		if (sip != null) {
			Toast.makeText(SoftPhone.this, name + ", SIP:" + sip,
					Toast.LENGTH_SHORT).show();
			call("sip:" + sip, id);
		} else
			Toast.makeText(SoftPhone.this, name + ", No tiene SIP:",
					Toast.LENGTH_SHORT).show();
	}
}
+---

		* Fill in the text box to type a contact and using the call button.

+---
final Button buttonCall = (Button) findViewById(R.id.call);
	buttonCall.setOnClickListener(new OnClickListener() {

		@Override
		public void onClick(View v) {
			TextView textRemoteUri = (TextView) findViewById(R.id.textRemoteUri);
			String remoteURI = "sip:";

			remoteURI += textRemoteUri.getText().toString();
			Integer idContact;
			idContact = controlcontacts.getId(textRemoteUri.getText().toString());
			call(remoteURI, idContact);
	}
});
+---

	The method <<<call>>> to make a call.

+---
private void call(String remoteURI, Integer id) {
	if (controller != null) {
		if (controller.getUa() == null)
			initControllerUAFromSettings();
		try {
			controller.call(remoteURI);
			Intent mediaIntent = new Intent(SoftPhone.this, MediaControlOutgoing.class);

			mediaIntent.putExtra("Id", id);
			mediaIntent.putExtra("Uri", remoteURI);
			startActivityForResult(mediaIntent, MEDIA_CONTROL_OUTGOING);
		} catch (Exception e) {
			e.printStackTrace();
		}
	} else
		notRegister();
}
+---

	When we destroy the activity.

+---
if (isExit) {
	signalManager.listen(signalListener, PhoneStateListener.LISTEN_NONE);
	if (controller != null)
		controller.finishUA();
	isRegister = false;
	ApplicationContext.contextTable.put("isRegister", isRegister);

	intentService = (Intent) ApplicationContext.contextTable
			.get("intentService");
	try {
		stopService(intentService);
	} catch (Exception e) {
		Log.e(LOG_TAG, "stopService " + e.getMessage() + "; " + e.toString());
	}
	ApplicationContext.contextTable.clear();
}
+---

* Services

** {{Principal service}}

	The definition of a notification in the notification bar, with the name <<Softphone>> that is associated with class <<SoftPhone.class>>.

+---
private NotificationManager mNotificationMgr;
private final static int NOTIF_SOFTPHONE = 1;
private final static int NOTIF_VIDEOCALL = 1;

private Notification mNotif;
private PendingIntent mNotifContentIntent;
private Intent notifIntent;
private String notificationTitle = "Softphone";
private static final int IC_LEVEL_ORANGE = 0;

mNotificationMgr = (NotificationManager) this
			.getSystemService(Context.NOTIFICATION_SERVICE);

mNotif = new Notification(R.drawable.icon, notificationTitle,
		System.currentTimeMillis());
mNotif.iconLevel = IC_LEVEL_ORANGE;
mNotif.flags |= Notification.FLAG_ONGOING_EVENT;

notifIntent = new Intent(this, SoftPhone.class);
mNotifContentIntent = PendingIntent
		.getActivity(this, 0, notifIntent, 0);
mNotif.setLatestEventInfo(this, notificationTitle, "",
		mNotifContentIntent);

mNotificationMgr.notify(NOTIF_SOFTPHONE, mNotif);
+---

	Collect <<controller>> of <<<ApplicationContext>>> and report <<controller>> implement the service <<<CallListener>>>.

+---
Controller controller = (Controller) ApplicationContext.contextTable
			.get("controller");
if (controller != null)
		controller.addListener(this);
+---

	One possible implementation of <<<incomingCall(String uri)>>>. Then run as explained in the documentation activity that is responsible for managing incoming calls, by adding <<<putExtra>>> the <<<uri>>> that has reached us.

+---
@Override
public void incomingCall(String uri) {
	Log.d(LOG_TAG, "Invite received");
	Intent mediaIntent = new Intent(this, MediaControlIncoming.class);
	mediaIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	mediaIntent.putExtra("Uri", uri);
	startActivity(mediaIntent);
	
}
+---
	
	One possible implementation of <<<callSetup>>>. The call has been established so we must tell the principal application should stop the activity that managing outgoing calls with a message (<<<handler.sendMessage(msg)>>>). And we must start the service that manages active calls.

+---
@Override
public void callSetup(NetworkConnection networkConnection) {
	ApplicationContext.contextTable.put("networkConnection", networkConnection);
	
	Message msg = new Message();
	Bundle b = new Bundle();
	b.putString("finishActivity", "MEDIA_CONTROL_OUTGOING");
	msg.setData(b);
	handler.sendMessage(msg);

	videoCallIntent = new Intent(this, VideoCallService.class);
	videoCallIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	startService(videoCallIntent);
}
+---
	
	Method for sending messages to the application signed. In this case will be the main application.

+---
public interface ServiceUpdateUIListener {
	public void update(Message message);
}


public static ServiceUpdateUIListener UI_UPDATE_LISTENER;

public static void setUpdateListener(ServiceUpdateUIListener l) {
	UI_UPDATE_LISTENER = l;
}

private Handler handler = new Handler() {
	@Override
	public void handleMessage(Message msg) {
		UI_UPDATE_LISTENER.update(msg);
	}
};
+---

	By destroying the service, cancel the notifications that may be in the notification bar and stop the service to manage active calls.

+---
mNotificationMgr.cancel(NOTIF_SOFTPHONE);
mNotificationMgr.cancel(NOTIF_VIDEOCALL);
stopService(videoCallIntent);
+---


** {{Service to an active call}}

	Recovery <<controller>> from <<<ApplicationContext>>>. MediaSession object creation and audio components. Objects are also added audio component in the <<<ApplicationContext>>> to access them from another part of the application.

+---
Controller controller = (Controller) ApplicationContext.contextTable
			.get("controller");
if (controller == null) 		
	return;

MediaSessionAndroid mediaSession = controller.getMediaSession();

try {
	audioPlayerComponent = mediaSession.createMediaComponent(MediaComponentAndroid.AUDIO_PLAYER, Parameters.NO_PARAMETER);
	
	Parameters params = new ParametersImpl();
	params.put(MediaComponentAndroid.STREAM_TYPE, AudioManager.STREAM_MUSIC);
	audioRecorderComponent = mediaSession.createMediaComponent(MediaComponentAndroid.AUDIO_RECORDER, params);
} catch (MsControlException e) {
	e.printStackTrace();
}
ApplicationContext.contextTable.put("audioPlayerComponent", audioPlayerComponent);
ApplicationContext.contextTable.put("audioRecorderComponent", audioRecorderComponent);
+---

	Recovery <<<NetworkConnection>>> of <<<ApplicationContext>>> and boot configuration and audio components.

+---
NetworkConnection nc = (NetworkConnection) ApplicationContext.contextTable
	.get("networkConnection");
if (nc == null) 
	return;
		
try {
	if (audioPlayerComponent != null) {
		audioPlayerComponent.join(Direction.SEND,
				nc.getJoinableStream(StreamType.audio));
		audioPlayerComponent.start();
	}
	if (audioRecorderComponent != null) {
		audioRecorderComponent.join(Direction.RECV,
				nc.getJoinableStream(StreamType.audio));
		audioRecorderComponent.start();
	}
	
} catch (MsControlException e) {
	e.printStackTrace();
}
+---

	Start the activity that controls the management of a call.

+---
videoCallIntent = new Intent(this, VideoCall.class);
videoCallIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(videoCallIntent);
+---

	By destroying the service, change the notification for a call by the application.

+---
mNotificationMgr.cancel(NOTIF_VIDEOCALL);
mNotif = new Notification(R.drawable.icon, notificationTitleSoft,
		System.currentTimeMillis());

notifIntent = new Intent(this, SoftPhone.class);
mNotifContentIntent = PendingIntent
		.getActivity(this, 0, notifIntent, 0);
mNotif.setLatestEventInfo(this, notificationTitleSoft, "",
		mNotifContentIntent);

mNotificationMgr.notify(NOTIF_SOFTPHONE, mNotif);
+---

	Stop the audio components.

+---
if (audioPlayerComponent != null)
	audioPlayerComponent.stop();

if (audioRecorderComponent != null)
	audioRecorderComponent.stop();
+---

	And send a message confirming that the call has ended. In this case, you will be sent to the activity which manages the active call as I have seen in the main service.

+---
Message msg = new Message();
Bundle b = new Bundle();
b.putString("Call", "Terminate");
msg.setData(b);
handler.sendMessage(msg);
+---

* Contact Management

	Possible implementation of obtaining a contact name from your <<id>>. The idea is to make an inquiry, like a sql query in which we indicate the user ID we want. If it exists, we can return the name.

+---
public String getName(Integer id) {

	int contact_id = -1;
	String name = "";
	contact_id = id;

	Cursor pidcursor = c.getContentResolver().query(
			ContactsContract.Contacts.CONTENT_URI,
			new String[] { ContactsContract.Contacts.DISPLAY_NAME },
			ContactsContract.Contacts._ID + "=" + contact_id, null, null);
	if (pidcursor != null) {
		if (pidcursor.moveToFirst()) {
			name = pidcursor.getString(0);
		}
	}
	return name;
}
+---

	Another way of performing this query is using the data that Android provides us when we access from the agenda. In this case the query is performed using data <<<Intent>>>.

+---
public String getName(Intent data) {
	Cursor cursor = c.getContentResolver().query(data.getData(), null,
			null, null, null);

	String name = null;

	if (cursor.moveToFirst()) {
		int nameIdx = cursor
				.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME);

		name = cursor.getString(nameIdx);
	}
	if (name != null)
		return name;
	else
		return null;
}
+---

	To recover the <<id>> of a possible contact, looking through his <<<uri>>> into contact with any content type <<<CONTENT_URI>>>. If the contact is returned there <<id>>.

+---
public Integer getId(String sipUri) {

	Integer idContact = -1;
	String sipUriContact = "";

	String whereIm = ContactsContract.Data.MIMETYPE + " = ?";
	String[] whereParametersIm = new String[] { ContactsContract.CommonDataKinds.Im.CONTENT_ITEM_TYPE };

	Cursor contactsIm = c.getContentResolver().query(
			ContactsContract.Data.CONTENT_URI, null, whereIm,
			whereParametersIm, null);

	while (contactsIm.moveToNext()) {

		sipUriContact = contactsIm.getString(contactsIm
				.getColumnIndexOrThrow(ContactsContract.Data.DATA1));
		if (sipUri.equals(sipUriContact)) {
			int idIdx = contactsIm
					.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.CONTACT_ID);
			idContact = contactsIm.getInt(idIdx);

			break;
		}
	}
	contactsIm.close();
	return idContact;
}
+---

	Recovery the photo  for a contact using your <<id>>. First contact will be sought on the agenda for once found, get your picture using the <<<photo_id>>>.

+---
public Bitmap getPhoto(Integer id) {

	byte[] photo = null;
	Bitmap bm = null;
	int contact_id = -1;
	int photo_id = -1;

	if (id != -1){
		contact_id = id;

		Cursor pidcursor = c.getContentResolver().query(
				ContactsContract.Contacts.CONTENT_URI,
				new String[] { ContactsContract.Contacts.PHOTO_ID },
				ContactsContract.Contacts._ID + "=" + contact_id, null,
				null);
		if (pidcursor != null) {
			if (pidcursor.moveToFirst()) {
				photo_id = pidcursor.getInt(0);
			}
		}

		Cursor pcursor = c.getContentResolver().query(
				ContactsContract.Data.CONTENT_URI,
				new String[] { ContactsContract.Data.DATA15 },
				ContactsContract.Data._ID + "=" + photo_id, null, null);
		if (pcursor.moveToFirst()) {
			photo = pcursor.getBlob(0);
		}
		if (photo != null) {
			bm = BitmapFactory.decodeByteArray(photo, 0, photo.length);
		}
	}
	else Log.d(LOG_TAG, "Id is null, not contatc");
	return bm;
}
+---

* Call Management

** Management emission a call

	When creating the activity data is retrieved as the <<<uri>>> and <<id>> and from there you try to retrieve the data and the photo of the contact that calls from the phonebook. If you are on the agenda is filled with data interface so we know who to call.

+---
Bundle extras = getIntent().getExtras();
String uri = (String) extras.getSerializable("Uri");
Integer id = (Integer) extras.getSerializable("Id");
TextView text = (TextView) findViewById(R.id.outgoing_sip);
text.setText(uri);

ImageView imageCall = (ImageView) findViewById(R.id.image_call);

ControlContacts controlcontacts = new ControlContacts(this);

Bitmap bm = controlcontacts.getPhoto(id);

if (bm != null) {

	imageCall.setImageBitmap(bm);
}
+---

	Cancelar una llamada saliente.

+---
controller.cancel();
finish();
+---

** Management receiving a call

	When creating the activity data is retrieved as the <<<uri>>> and from there you try to retrieve the data and the photo of the contact that calls from the phonebook. If you are on the agenda is filled with data interface so we know who is calling us.

+---
Bundle extras = getIntent().getExtras();

String uri = (String) extras.getSerializable("Uri");

TextView text = (TextView) findViewById(R.id.incoming_sip);
text.setText(uri);

String[] sipArray = uri.split(":");
String sipUri = "";
if (sipArray.length > 1) sipUri = sipArray[1];
else sipUri = sipArray[0];

Integer idContact = controlcontacts.getId(sipUri);

if (!idContact.equals("")){
	ImageView imageCall = (ImageView) findViewById(R.id.image_call);
	Bitmap bm = controlcontacts.getPhoto(idContact);
	if (bm != null) {
		imageCall.setImageBitmap(bm);
	}
}
+---

	Operation of the vibrator to simulate the call.

+---
Vibrator vibrator;
vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);
long[] pattern = { 0, 1000, 2000, 3000 };

vibrator.vibrate(pattern, 1);
+---

	Accepting a call. Cancel vibration, accept the call to <<<aceptCall()>>> and end the activity.

+---
vibrator.cancel();
if (controller != null){
	try {
		controller.aceptCall();
	} catch (Exception e) {
		e.printStackTrace();
	}
}
finish();
+---

	To reject the call would be the same but using:

+---
controller.reject();
+---


