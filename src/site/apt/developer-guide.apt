   ------
   Kurento Android SDK developer's guide
   ------
   ------
   Date
   ------
 

Introduction

	This guide provides required information to incorporate Kurento Android SDK (KAS)
	to applications. Three main blocks are found through the document

		* <<Control Plane>>: Describes the KAS' SIP User Agent control interface. Contains
		detailed information regarding contact management and call handling.

		* <<User Plane>>: Shows the mechanisms available to build a media distribution network associated with a call.
Provides configuration details of basic building blocks enabling multimedia relay between in/out devices network
interfaces.

		* <<Application Android>>. This section covers the a set of recommended steps intended to create
		 an application that incorporates Kurento Android Android SDK. This are just recommendations based
		 in {{{../docs/kas-softphone}K-Phone}} experience, but other options might be also valid.

Control Plane

	Control function consist of a SIP User Agent providing connectivity with VoIP networks. Figure below shows
	relationships with the application and the rest of components architecture shown in the figure below.

[images/diagrama-control-plane.png]

* Concepts

** <<UA>>

	The user agent manages the SIP protocol. Instantiates a {{{http://java.net/projects/jsip}JAIN-SIP}} 
	based SIP stack to handle message creation and relay. The UA is able to host multiple <<<SipEndPoint>>>,
	each one seving one user (SIPURI)
	The UA API is designed to hide SIP protocol complexities and provide a user oriented service layer. Following
	list provides a summary of most relevant methods.

*** <<<registerEndPoint(String user, String realm, String password, int expires, SipEndPointListener handler)>>>

	This method registers a user (SIPURI=sip:<<<user>>>@<<<realm>>>) contact against the REGISTRAR configured 
	during <<<UA>>>	instantiation. The application defines also the registration period through parameter 
	<<<expires>>>. Default value for this parameter is 3.600 seconds. Setting this parameter to 0 causes
	the UA to unregister the contact.  
	
	Registering an endpoint also requires a reference to the listener that will handle SIP events. This listener
	must be implemented by the application that controls the SIPURI life cycle.

***<<<terminate()>>>

	This method unregister all SIPURIS hosted by the UA and terminates the SIP stack. The UA enters a
	termination state from where it can not recover
	
**  <<SipEndPoint>>. 

	The SIP endpoint represents a SIPURI with a registered contact. It is the user's service point for call
	management that Kurento Android SDK provides to applications. The API is aimed to provide
	a call control abstraction layer. 
	

***<<<dial(String remoteParty, SipCallListener callController)>>>

	This method starts an outgoing call to a remote contact identified by the <<<remoteParty>>> SIPURI.
	In order to set up a call, the <<<SipEndPoint>>> requires a reference to the call listener that
	will handle call events. This listener is implemented by the application and controls the call life
	cycle

**  <<SipEndPointEvent>>. 

	Endpoint events are received by the SIP handler notify relevant state changes experienced by
	the <<<SipEndPoint>>>. In order to receive this events the handler must implement the interface
	<<<SipEndPointListener>>>.
	
		***<<<SipEndPointListener>>>
	
			*<<<onEvent()>>>: This method is used by the <<<SipEndPoint>> to send events 
			of type <<<SipEndPointEvent>>>

		The <<<SipEndPointListener>>> receiving notifications should be able to handle the following events:
		
			* <<<INCOMING_CALL>>>, Notifies an INVITE message has been received by the UA addressed to this
			<<<SipEndPoint>>>, i.e. someone is trying to make call.

			* <<<REGISTER_USER_SUCESSFUL>>>, Issued after successful register of SIPURI's contact 

			* <<<REGISTER_USER_FAIL>>>, This event is sent if a server internal or protocol error 
			is detected during registration process.
	
			* <<<REGISTER_USER_NOT_FOUND>>>, The user does not exist within the REGISTRAR or and authentication
			problem has been found.


+---
@Override
public void onEvent(SipEndPointEvent event) {
	SipEventType eventType = event.getEventType();
	if (SipEndPointEvent.INCOMING_CALL.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
	if (SipEndPointEvent.REGISTER_USER_SUCESSFUL.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
	if (SipEndPointEvent.REGISTER_USER_FAIL.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
	if (SipEndPointEvent.REGISTER_USER_NOT_FOUND.equals(eventType)) {
		this.pendingEndPointEvent = event;
		// Process the event.
	}
}
+---

**  <<SipCall>>. 

	This object handles the call during its life cycle from instantiation, to termination.
	
***<<<accept()>>>

	Allows the application to accept an incoming call signaled by the <<<SipEndPoint>>>. The call
	is accepted by sending a <<<200 OK>>> response
	
	Execute this method with an outgoing call will rise an error.

***<<<reject()>>>

	Allows the application to reject an incoming call. It causes the SIP stackt to 
	respond with DECLINE SIP message.

***<<<hangup()>>>

	This method ends a call. It causes the SIP stack to send a BYE SIP request to the remote party.

***<<<cancel()>>>

	This allows the caller to cancels outgoing calls.
	
***<<<getNetworkConnection(JoinableStream.StreamType media)>>>

	This method returns the network connection associated to a successful call setup. The
	<<<NetworkConnection>>> provides a control interface of transmission and reception pipes that
	enables media relay between network interfaces and in/out elements (camera, screen, microphone ...)
	
	Method returns a null value if the call state is different from CONNECTED.
		
***<<<getMediaTypesModes()>>>

	This method provides a MAP containing connection modes of every channel in the call.
	Connection mode will depend on internal configuration, provided during <<<UA>>> instantiation
	and remote peer requirements.
	
	Supported channels are AUDIO and VIDEO. They can present any of the following connection
	modes: send only, receive only, send-receive

**  <<SipCallEvent>>.

	Call events notify state transitions within the <<<SipCall>>>. They are sent to the registered listeners
	implementing interface <<<SipCallListener>>>
	
	
		*** <<<SipCallListener>>>. 
	
			*<<<onEvent()>>>: This method is used by the <<<SipCall>> to send events 
			of type <<<SipCallEvent>>>

		The application implementing this listener  should be able to handle following events:

			* <<<CALL_SETUP>>>, Notifies a successful call setup.

			* <<<CALL_TERMINATE>>>, This event is sent when call has been terminated, either by local 
			or remote party.
	
			* <<<CALL_REJECT>>>, This event is sent when outgoing calls are rejected by remote peer.
		
			* <<<CALL_CANCEL>>>, This event is sent when incoming calls are canceled by remote peer.
	
			* <<<CALL_ERROR>>>, Notifies an internal non recoverable error that prevents the call to progress.


+---
@Override
public void onEvent(SipCallEvent event) {
	SipEventType eventType = event.getEventType();

	if (SipCallEvent.CALL_SETUP.equals(eventType)) {
		currentCall = event.getSource();
		// Process the event.
	} else if (SipCallEvent.CALL_TERMINATE.equals(eventType)) {
		// Process the event.
	} else if (SipCallEvent.CALL_REJECT.equals(eventType)) {
		// Process the event.
	} else if (SipCallEvent.CALL_ERROR.equals(eventType)) {
		// Process the event.
	}
}
+---

** <<SipConfig>>. 

	This object is the mechanism used to provide the UA Factory with required SIP configuration. Supported
	configuration keys are defined in the {{{../kas-sipua-impl/apidocs/com/kurento/commons/sip/util/SipConfig.html}<<<SipConfig>>>}}}
	reference guide

** <<MSControlFactory>>. 

	This factory provides a static method to create <<<MediaSessionAndroid>>> instances, used to control and 
	manage media core capabilities.

**  <<MediaSessionAndroid>>. 

	This is the media core central class. It provides factory methods to instantiate <<<MediaComponentAndroid>>>
	and <<<NetworkConnection>>>, used to relay media between device's in/out components and the active network
	interface. <<<UAFactory>>> requires an instance of <<<MediaComponentAndroid>>> in order to create <<<NetworkConnections>>>
	that service the User Plane.
		
***<<<createMediaComponent(Configuration<MediaComponent> predefinedConfig, Parameters params)>>>

	Factory method to instantiate media components.
	
** <<MediaComponentAndroid>>. 

	Media components attach a media pipe to device's in/out components enabling media relay to other components or
	network interfaces. 

* SIP Agent initialization.

	The User Agent must be initialized in order to provide a SIP service to applications. It can
	manage one or more SIPURI, multiplexing calls among then. The SIP User Agent must be restarted
	 only when significant changes occur, such as an IP change, active interface change, 
	proxy address or similar.
	
	Internally it has a SIP stack that handles messages exchange between remote peers. Kurento Android SDK
	uses for this purpose {{{http://java.net/projects/jsip}JAIN-SIP}}

	Initialization of the SIP User Agent requires two sets of configurations:
	
	* <<SIP Configuration>>: Sets the parameters required to connect the UA to a VoIP network. It consists
	 of the parameters shown in the next table.
	
	
*--------*-----------*----*--------*----------------------------------------------------------------*
| <<Name>> | <<M/O>> |<<Type>>|<<Range>>    | <<Description>>                                                    |
*--------*-----------*----*--------*----------------------------------------------------------------+
| localAddress| M | String | NA    | Sets the IP address used by the SIP stack. If the IP address does not |
|             |   |        |       | correspond to an active interface, then it rises an exception  |
*--------*-----------*----*--------*----------------------------------------------------------------+
| localPort   | O | Integer| 1-2^16| Sets the local port where the SIP stack binds |
*--------*-----------*----*-------*----------------------------------------------------------------+
| proxyAddress| M | String | NA    | Set the SIP PROXY address. This is also the address used |
|             |   |        |       |as SIP REGISTER                           |
*--------*-----------*----*-------*----------------------------------------------------------------+
| proxyPort| M | String |  1-2^16  | Set the remote port in the SIP PROXY where messages are sent|
*--------*-----------*----*-------*----------------------------------------------------------------+
(M: Mandatory; O: Optional)


	* <<Media Configuration>>: It provides relevant information required by media core for call negotiation 
	and setup. Next table provides a complete reference to supported parameters:

*--------*-----------*----*-------*--------------*--------------------------------------------------*
| <<Basic configuration>> |
*--------*-----------*----*-------*--------------*--------------------------------------------------*
| <<Name>> | <<M/O>> | <<Type>> | <<Range>> | <<Default value>> | <<Description>> |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| NET_IF |  M | NetIF | [WIFI, MOBILE] | | Defines active network interface: WIFI or MOBILE. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| LOCAL_ADDRESS | M | InetAddress | NA | |Provides the local IP address of active interface.|
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| MAX_BANDWIDTH | O | Integer | NET_IF.MOBILE:\ [150000,\ 384000]\ | NET_IF.MOBILE:\ 384000\ | Limits max bandwidth usage, in bps(bits per second). |
|				|	|		  | NET_IF.WIFI:\ [150000,\ 1500000]	| NET_IF.WIFI:\ 1500000  |																	|	
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| STREAMS_MODES | O | Map\<MediaType,\ Mode\> | [SENDRECV, SENDONLY, RECVONLY] | SENDRECV | Defines connection mode for each media stream.|
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| AUDIO_CODECS   | O | List\<AudioCodectype\> | [AMR, MP2] | [AMR, MP2] |Configures the list of enabled audio codecs. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| VIDEO_CODECS   | O | List\<VideoCodectype\> | [H263, MPEG4]| [H263, MPEG4] |	Configures the list of enabled video codecs . |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| <<Advanced configuration>> |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| FRAME_SIZE | O | Dimension | NA | 352x288 | Sets the maximum frame size to be used, in pixels (width x height).  |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| MAX_FRAME_RATE | O |Integer|  [1, MAX_INT] | 15 |Sets the max frame rate taht will be used. |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| GOP_SIZE | O |Integer| [0, MAX_INT] | 6 |  Max number of frames in a group of pictures, set 0 for intra_only.  |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
| FRAMES_QUEUE_SIZE | O | Integer | [2, MAX_INT] | 2 | Configures the size of jitter buffer in frames. Large numbers will cause latency increase |
*--------*-----------*----*-------*---------------*-------------------------------------------------+
(M: Mandatory; O: Optional)
	
	
	Creation of a SIP UA instance requires two previous initialization procedures. First,
	the initialization of parent media factory <<MSControlFactory>>, as shown in the following snippet.
	
+---
Parameters params = MSControlFactory.createParameters();

params.put(MediaSessionAndroid.NET_IF, NetIF.MOBILE);

InetAddress localAddress =...;
params.put(MediaSessionAndroid.LOCAL_ADDRESS, localAddress);

int maxBW = 320000;
params.put(MediaSessionAndroid.MAX_BANDWIDTH, maxBW);

Map<MediaType, Mode> callDirection = new HashMap<MediaType, Mode>();
callDirection.put(MediaType.VIDEO, Mode.SENDRECV);
callDirection.put(MediaType.AUDIO, Mode.SENDRECV);
params.put(MediaSessionAndroid.STREAMS_MODES, callDirection);

ArrayList<AudioCodecType> audioCodecs = new ArrayList<AudioCodecType>();
audioCodecs.add(AudioCodecType.AMR);
audioCodecs.add(AudioCodecType.MP2);
params.put(MediaSessionAndroid.AUDIO_CODECS, audioCodecs);

ArrayList<VideoCodecType> videoCodecs = new ArrayList<VideoCodecType>();
videoCodecs.add(VideoCodecType.H263);
videoCodecs.add(VideoCodecType.MPEG4);
params.put(MediaSessionAndroid.VIDEO_CODECS, videoCodecs);

Dimension frame_size = ...;
params.put(MediaSessionAndroid.FRAME_SIZE, frame_size);

int maxFR = 12;
params.put(MediaSessionAndroid.MAX_FRAME_RATE, maxFR);

int gopSize = 8;
params.put(MediaSessionAndroid.GOP_SIZE, gopSize);

int maxQueueSize = 3;
params.put(MediaSessionAndroid.FRAMES_QUEUE_SIZE, maxQueueSize);


MediaSessionAndroid mediaSession = MSControlFactory.createMediaSession(params);
+---	

	Second, initialization of the SIP configuration, as follows.
	
+---
SipConfig sipConfig = new SipConfig();
sipConfig.setLocalAddress(localAddress.getHostAddress());
sipConfig.setLocalPort(6060);
sipConfig.setProxyAddress(proxyIP);
sipConfig.setProxyPort(proxyPort);
+---

	Once the factories are configured, a <<MediaSession>> object is created and passed as parameter
	 to instantiate a SIP User Agent.

+---
mediaSession = MSControlFactory.createMediaSession(params);
UaFactory.setMediaSession(mediaSession);

ua = UaFactory.getInstance(sipConfig);
+---

	It is important to notice that any change in media parameters requires a new <<<MediaSession>>>, and
	hence the UA has to be recreated.
	
	To Terminate the User Agent, either because the application is finished, or because a reconfiguration
	is required, the following code has to be run
	
+---
ua.terminate();
+---


* Contact management

** Register contact

	UA registers a contact when its associated SIPURI must support incoming calls. Kurento Android SDK
	models the user contact with the object <<<SipEndPoint>>>, that is instantiated and returned by method
	<<<registerEndPoint(String user, password, String String int expires, realm, SipEndPointListener
	    handler)>>>:

	* <<user>>: User name to be registered.

	* <<realm>>: Domain name to be register.

	* <<password>>: User password, required only when AUTH is activated.

	* <<expires>>: Register expires time. Default value is 3600 seconds. A 0 value is interpreted as a unregister.

	* <<handler>>: Reference to the object that will be receiving endpoint events.

	Method registerENdPoint animatedly returns a <<<SipEndPoint>>> instance from where call control can
	 be performed.

+---
endPoint = ua.registerEndPoint(localUser, localRealm, localPassword, expires, this);
+---

** Unregister

	Contact unregister can be achieved by setting the <<<expires>>> header to 0

+---
expires = 0;
endPoint = ua.registerEndPoint(localUser, localRealm, localPassword, expires, this);
+---

* Outgoing calls

** Initiate a call

	A call can be initiated by method <<<SipEndPoint.dial()>>>. It is mandatory to provide the called party (SIPURI)
	and the call event handler to the endpoint. Method dial will immediately return a <<<SipCall>>> object
	enable the application full control over the call life cycle 
	
+---
currentCall = endPoint.dial(remoteURI, this);
+---

** Cancel a call

	Before the call moves to CONNECTED or ERROR states, the calling party can request the call to be canceled
	with method <<<SipCall.cancel()>>>. This will cause the SIP stack to send a CANCEL request and the call
	will move to state FINISHED.
	
	Call cancel can be only requested by calling party. Called party would reject the call.
		
+---
currentCall.cancel(); 
+---	

* Incoming calls

	Incoming calls are those initiated by the remote party. Every time an incoming call is 
	received, the <<<UA>>> performs following verifications
	
		* There is a registered SIPURI hosted by the <<<UA>>>. Otherwise a <<<404 NOT_FOUND>>> response is
		 sent back
		 
		* Requested media format is supported by media core. Otherwise a <<<415 UNSUPPORTED MEDIA TYPE>>> 
		response is sent back
	
	If SIPURI is locally hosted and media is supported an event is generated the The associated endpoint 
	notifies to the	handler with event <<<SipEndPointEvent.INCOMING_CALL>>> 
		
	The application can retrieve the <<<SipCall>>> from the event and must then accept or reject the call

** Accept call

	Method <<<accept()>>> causes the call to be accepted

+---
// handler implementing SipEndPointListener
// accept all calls

@Overide
public void onEvent(SipEndPointEvent event) {
...
   if (event.getEventType().equals(SipEndPointEvent.INCOMING_CALL)){
       SipCall incomingCall = event.getCallSource();
       incomingCall.accept();
   }
...
}
+---


** Reject call

	Method <<<reject()>>> causes the call to be rejected.
	
+---
// handler implementing SipEndPointListener
// reject all calls

@Overide
public void onEvent(SipEndPointEvent event) {
...
   if (event.getEventType().equals(SipEndPointEvent.INCOMING_CALL)){
       SipCall incomingCall = event.getCallSource();
       incomingCall.reject();
   }
...
}
+---
	
* Terminate call

	A <<<SipCall>>> can be terminated only if it is in CONNECTED state. Method
	<<<hangup()>>> will cause the SIP stack to send a BYE and the media core
	to free the media resources.
	
+---
currentCall.hangup();
+---

User Plane
	
	The User Plane function is able create media networks connecting in/out ports on remote
	devices, based in the  negotiation carried out by the Control Plane.
	Kurento Android SDK User Plane is implemented by {{{../kas-mscontrol}MSControl project}}, and
	consist of a set of basic building blocks implemented with ffmpeg that can interchange media
	when connected.
	
* Media initialization

	Media core requires a previous initialization before it can be used. This configuration is
	intended to provide environmental information (IP address, available bandwidth, etc.) and user
	preferences (enabled codecs, MAX bandwidth, etc.).
	
	Kurento Android SDK uses method <<<createMediaSession()>>> of parent factory <<MSControlFactory>> 
	to initialize  media core. The method takes a list of parameters defined in <SIP Agent initialization>
	and returns a <<<MediaSession>>> instance that will be used to create <<<MediaGroups>>> and 
	<<<NetworkConnections>>>.
	
	<<<MediaGroups>>> are created by the application, based in the model of use and business logic.
	<<<NetworkConnection>>> is automatically created by the <<<UA>>> after call setup is successful.
	Code below shows an example of how to get the connection object after an event has been received
	from the call. If the event is different from CALL_SETUP, the <<<NetworkConnection>>> instance will
	be <<<null>>>

+---
SipCall currentCall = event.getSource();
currentCall.getNetworkConnection(StreamType.video);
+---

	A <<<MediaComponent>>> can be created for each stream type (audio/video) and direction (SEND/RECV) 
	of the call. When connecting <<<MediaComponent>>> and <<<NetworkConnection>>> is important
	to verify there is at least a connection alternative where streams in both sides are the same type
	and opposite direction.
		
* {Audio Components}

 	There are reception and transmission audio components. Method <<<createMediaComponent>>>
 	of factory <<<MediaSessionAndroid>>> is used to create audio instances. It is required
 	the component name, stream direction and speaker id.
		 
		* Create a reception audio component that plays through the external speaker:

+---
Parameters params = MSControlFactory.createParameters();

params.put(MediaComponentAndroid.STREAM_TYPE, AudioManager.STREAM_MUSIC);
audioRecorderComponent = mediaSession.createMediaComponent(
	MediaComponentAndroid.AUDIO_RECORDER, params);
+---	

		* Next code shows how to create an audio emision component getting audio
		from microphone.
			
+---
audioPlayerComponent = mediaSession.createMediaComponent(
	MediaComponentAndroid.AUDIO_PLAYER, Parameters.NO_PARAMETER);
+---

		* Audio components can be joined to <<<NetworkConnections>>> in order to receive or send
	media to remote peers. It is important to notice the <<<NetworkConnection>>> will relay media
	only after a successful call set up has been completed. If the <<<NetworkConnection>>> is not
	connected, media will be lost.
	 
			* Connect audio receiver component to a network connection.

+---
NetworkConnection nc = sipcall.getNetworkConnection();
audioRecorderComponent.join(Direction.RECV, nc.getJoinableStream(StreamType.audio));
audioRecorderComponent.start();
+---

			* Connect audio output component to a network connection.
		
+---
NetworkConnection nc = sipcall.getNetworkConnection();
audioPlayerComponent.join(Direction.SEND, nc.getJoinableStream(StreamType.audio));
audioPlayerComponent.start();
+---

		* Next code shows how to stop audio components, in case transmission has to terminate
	
+---
audioRecorderComponent.stop();
audioPlayerComponent.stop();
+---

* {Video components}

	Creation of the video components is very similar to the audio case seen before. It also uses a method 
	<<<createMediaComponent>>> from <<<MediaSessionAndroid>>>, but with a different set of parameters.
	Video players require the application to provide the <<SurfaceView>> 
	(is the screen space where it will display video received), the <<width>> and <<length>> of device's 
	screen.
	
	* Video receiver component, adding the <<SurfaceView>>, <<height>> and <<width>> 
	of the screen of the device:

+---
DisplayMetrics dm = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(dm);
int Orientation = getWindowManager().getDefaultDisplay().getOrientation();

Parameters params = MSControlFactory.createParameters();

params.put(MediaComponentAndroid.VIEW_SURFACE,
		(View) findViewById(R.id.video_receive_surface));
params.put(MediaComponentAndroid.DISPLAY_WIDTH, dm.widthPixels);
params.put(MediaComponentAndroid.DISPLAY_HEIGHT,
		dm.heightPixels);
videoRecorderComponent = mediaSession.createMediaComponent(
		MediaComponentAndroid.VIDEO_RECORDER, params);
+---

	* Video output component, adding the <<SurfaceView>> and the orientation of the device:

+---
Parameters params = MSControlFactory.createParameters();
params.put(MediaComponentAndroid.PREVIEW_SURFACE,
		(View) findViewById(R.id.video_capture_surface));
params.put(MediaComponentAndroid.DISPLAY_ORIENTATION, Orientation);
videoPlayerComponent = mediaSession.createMediaComponent(
		MediaComponentAndroid.VIDEO_PLAYER, params);
+---

	* Video components can be also connected to a network interface:
	
		* Connect a video receiver component to a network interface for data reception:

+---
NetworkConnection nc = sipCall.getNetworkConnection()
videoRecorderComponent.join(Direction.RECV, nc.getJoinableStream(StreamType.video));
videoRecorderComponent.start();
+---

		* Connect a video output component to a network interface for data delivery:
	
+---
NetworkConnection nc = sipCall.getNetworkConnection()
videoPlayerComponent.join(Direction.SEND, nc.getJoinableStream(StreamType.video));
videoPlayerComponent.start();
+---	

	Video components are terminated as shown in the following code:

+---
videoRecorderComponent.stop();
videoPlayerComponent.stop();
+---


Creating an Android application

	This section will provide hints and recommendations for application development including
	Kurento Android SDK. The guide will cover configuration files, activities and services, and 
	how to incorporate call handling and media management. 
	
	The diagram shows a complete architecture, including activities, services 
	and components required for an application.

[images/diagrama-tk-softphone.png]

* Configuration file {AndroidManifest.xml}
	
	Configuration file (AndroidManifest.xml) of an Android application is very important, 
	because defines:
		* Permissions the user must agree with during installation. Required permission 
		is quite dependent on the application model of use, but in general, Kurento Android SDK
		will require the ones listed below:

+---
<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
<uses-permission android:name="android.permission.CAMERA"></uses-permission>
<uses-permission android:name="android.permission.RECORD_AUDIO"></uses-permission>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
<uses-permission android:name="android.permission.INTERNET"></uses-permission\>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<uses-permission android:name="android.permission.READ_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.WRITE_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission>
+---
			
		A complete list of permissions can be found in 
		 {{{http://developer.android.com/reference/android/Manifest.permission.html}Android developer's guide}}
		 		
		* Activities

+---			
<activity android:name="kas.videocall.VideoCall" android:label="Video Call" 
android:theme="@android:style/Theme.NoTitleBar.Fullscreen" android:screenOrientation="landscape" 
android:launchMode="singleTop" \>
+---
				
		* Services that have to wake up:
			
+--- 
<service android:enabled="true" android:name="kas.softphone.SoftPhoneService" \>
+---
			
		* Intent filter: Within the main activity configuration it is useful to include the 
		a section called <<{{{http://developer.android.com/guide/topics/manifest/intent-filter-element.html}intent-filter}}>>.
		This configuration will enable direct access from the agenda to the call handler for all
		contacts with a field based in a given <schema>. The {{{../kas-softphone}K-phone}}} defines
		the schema <<<"sip:user@server.net">>>. When selecting that field it will automatically initiate
		the call
		
+---
<intent-filter>
	<action android:name="android.intent.action.SENDTO" \>
	<category android:name="android.intent.category.DEFAULT" \>
	<data android:scheme="sip" \>
	<data android:scheme="imto" \>
<\intent-filter> 
+---	

	Each element required by the application must be defined 
	in this file. Detailed information on setting AndroidManifest.xml file can be found in the  
	{{{http://developer.android.com/guide/topics/manifest/manifest-intro.html}Android developer's guide}}


* Activities

	Any application including Kurento Android SDK should include following list of activities

	** {{Main activity}}
	
	** Connection Preferences
	
	** Media Preferences
	
	** Call reception
	
	** Call initiation
	
	** Media management


* Services

	Kurento Android SDK application are likely to need the services listed next
	
	** {{Main service}}
	
	** {{Service to an active call}}


* Controller

	There should be a class that must implement some interfaces: <<<SipEndPointListener, SipCallListener, CallNotifier and InterfacePhone>>>. This class might be called <<"controller">>. It will be responsible for controlling and managing all the events SIP we can get  or we can send. Also, you must implement the normal behavior of a phone as a call to accept, reject, etc ... This class will notify the listener to subscribe.

** SipEndPointListener

	As explained in the Control Plane, implementing this interface will be able to receive some events and the application should behave as expected of her:

		* <<<INCOMING_CALL>>>, this event means that someone is making a call, so from the class <<controller>> have to notify the <<<listener>>> you have added a call is coming. In this case you must invoke a method on an object of the interface <<<CallListener>>>, which we shall discuss in the {{Principal Service}} who shall implement this interface, called <<<incomingCall (String uri )>>>. Basically what we will do is start the activity responsible for receiving calls.
	
		* <<<REGISTER_USER_SUCESSFUL>>>, this event means that the register with the connection settings are correct and have been checking on the server. In this case as in the previous one, is a method of an interface object <<<CallListener>>> who will have to invoke, called <<<registerUserSucessful()>>>. This method is responsible for sending the user to know that your registration application has been successful.

		* <<<REGISTER_USER_FAIL>>>, this event signifies that registration was incorrect. The method will be called <<<registerUserFailed()>>> and be responsible for sending the user to know that your registration application has been wrong.
	

** SipCallListener

	The implementation of this method in the class <<controller>> should be able to handle the next events, as in the previous section, the method call will be an object of the interface <<<CallListener>>> that will be implemented by the {{Principal Service}}:

	* <<<CALL_SETUP>>>, this event means that the call has been established and can close the activity responsible for monitoring or issuing calls or receiving calls and start the activity and service that will manage the media, both video audio. This will be done by calling <<<callSetup(NetworkConnection networkConnection)>>>.

	* <<<CALL_TERMINATE>>>, this event means that the call has been terminated by any of the users, so will have to stop the service and activity that is responsible for managing a call. This will be done by calling <<<callTerminate()>>>.
	
	* <<<CALL_REJECT>>>, this event means that the call has been rejected by the contact, so you have to close the activity manages the outbound. This will be done by calling <<<callReject()>>>.
		
 
** InterfacePhone 

	This interface represents the basic actions of a phone:
	
		* <<<aceptCall()>>>. Accept an incoming call.

		* <<<reject()>>>. Reject an incoming call.

		* <<<call(String remoteURI)>>>. Making an outgoing call to a contact.

		* <<<hang()>>>. Hang up a call.

*** <<<aceptCall()>>>
	
	This method be called from the activity that is responsible for management of incoming calls. The implementation of this method must collect call data and call the <<<accept()>>> of the class <<<SipCall>>>.  In this way is sent via the SIP call has been accepted.

*** <<<reject()>>>

	This method  be called from the activity that is responsible for management of incoming calls. The implementation of this method must collect call data and call the method <<<reject()>>> of the class <<<SipCall>>>. This will be sent using the SIP call has been rejected.


*** <<<call(String remoteURI)>>>

	This method is called from the main activity of the application or from the activity that is responsible for managing outbound calls from a contact. You must be at the Uri parameter of the contact you want to make the call. In implementing this method, you use an object of class <<<SipEndPoint>>>, which will be defined in the user register (be seen in the section where registered users), using the method <<<dial (String remoteParty, Direction direction, SipCallListener callController)>>> which will send through the SIP invitation message.

*** <<<hang()>>>

	This method is called from the activity that handles a call. The implementation of this method will use an object of class <<SipCall>> to call your method <<<hang()>>> in this way using the SIP protocol you can send the call completion message.


** CallNotifier

	This interface represents two methods to add or delete <<listener>> interface type <<<CallListener>>>, as mentioned above will be implemented in the {{Principal Service}}:
	
		* <<<addListener(CallListener listener)>>>. Add a <<listener>>.

		*<<<removeListener(CallListener listener)>>>. Delete a <<listener>>.


{Principal activity}

	This will be the activity that opens when you start the application, must be responsible for:
	
	* To configure the connection and media preferences.

	* Start the service.

	* Make calls.

	* Access to contacts.

	* Others...

* File XML

	This activity will have its own file <<<xml>>> which is defined as the user interface. This interface should have at least:

		** A <<<EditText>>> to write the <<<uri>>> of the person you wish to call.

		** A <<<Button>>> to access the contacts.

		** A <<<Button>>> to access the call history

* onCreate

	When you create an activity of the important steps that must be carried out is to check if the device has any active network, since for all SIP transactions is necessary. As it is, it should display an error message to the user and close the application before proceeding. If the device has any active network, then we can move forward.

	The activity will subscribe to the message delivery will perform the {{Princial Service}} in order to receive messages that arrive when the activity is in the foreground or background.

	Once we have done testing the network, it must collect data on preferences to configure the data required for registration to the SIP server (user, domain, server, port). It also collects information on the configuration of the media. If the collection of these data are correct, we proceed to attempt to register against the server set in preferences. According to the registration is successful or not, it will call the corresponding functions to send messages with the {{Principal service}}.

* onNewIntent

	As seen in the setup {{AndroidManifest.xml}}, how to launch an application can be <<<launchMode>>>. When configured in this way, you must implement this method, <<<onNewIntent>>>. This means that if there is an already created, not recreate it go directly to this method. In this part, you should check again if the network is active.

* onResume

	In this part of the application we first, subscribe to changes in network status that offers Android, thanks to this we can monitor changes occurring within the device's network interfaces and so act accordingly as explained in network control.

	Furthermore, we have the control over the buttons that are defined in the file <<<xml>>> interface configuration.

* Contacts

	When we opened the access  contacts activity and select a contact, to return to the activity in the section <<<onActivityResult>>>  be checked using the kind of help to get data from the agenda if the selected contact has set a <<<uri>>> correct. If so, the call is made.
	
* {Network control}

	It is important for these applications to be aware of changes in existing network interfaces in order to have control of changing ip's, network outages, change to 3G WIFI,  ... Therefore, as mentioned before the main activity will subscribe to the changes that exist in this section of the device.

	Recommended steps to follow are:
		
		** Save the interface type being used, WiFi or 3G. This will help us determine first whether we have any active network interfaces or not.

		** We must know whether the IP we were using is the same or changed. This is important because, although we are on the same interface IP changed if we need to re-register the server so that we can be reached without problems.

		** Finally, if you change the network interface or IP address of our device we finish our <<controller>> using the method <<<finishUA()>>>,  delete the data that exist in {{<<< ApplicationContext>>>}} and also to the main service. Once done, we will re-create the <<controller>> with the new configuration data, fill {{<<<ApplicationContext>>>}} with the necessary data and attempt to register again.

* Message Control

	The application must also subscribe to receive messages from the principal service. Since the service will send messages to the activity and that the registration was successful, erroneous or to have accepted the call and must close the outbound activity.


* Management receiving a call

	Only we can make a call when we have an address <<<uri>>> to be able to call. When you call, you will have to start the activity that is responsible for managing the emission calls. It is advisable to add them as parameters to this activity, the <<id>> the user that we have collected from the agenda and the <<<uri>>> the contact you want to call. Will the new activity ultimately responsible for carrying the call.

* Menu

	To access the application preferences should have a menu from which you can access them. In these menus you should also add a clause to exit the application.

* Application termination
	
	To finish,  you must:

	** Stop listening to network changes that exist in the device.

	** Stop the <<controller>> using the method <<<finishUA>>>.
	
	** Releasing the data stored in {{<<<ApplicationContext>>>.}}

	** Finish the principal service.

{Services}

	The creation of services is needed to control some events that can occur when the application is not in the foreground. This should create two services, one that handles all events of the SIP connection and another to manage the media during a call.

* {Principal service}

	The principal application service will be responsible for handling events that may arise from SIP, therefore, is responsible for implementing the interface <<<CallListener>>>.

	Some of the responsibilities that will have this service are:

	* When you start the service, you should start the notification that the application is open in the notification bar. At the time of creating the notification should be the main activity associated with this notification.

	* Added using the method <<<addListener()>>> object <<controller>>, which will recover thanks to {{<<<ApplicationContext>>>}} in order to receive events. In this way from <<controller>> can call our implementation of <<<CallListener>>>.

	* When we receive a call to <<<incomingCall(String uri)>>>, the activity should be initiated to manage the incoming call. In this way it will be the user who may accept or reject the call. On the other hand, because we are using a service, each time this method is invoked and if the application is in the background make it up this activity.

	* When we receive a call to <<<registerUserSucessful()>>> then it should be the principal activity with a message that the user is properly registered so that it can notify the user via a message.

	* When we receive a call to <<<registerUserFailed()>>> then it should be the main activity with a message that the user <<no>> correctly registered so that it can notify the user via a message.

	* When we receive a call to <<<callSetup(NetworkConnection networkConnection)>>> then it should be the main activity by a message that should stop the activity of issuing calls or receive calls as appropriate. Furthermore, you must start the service for a call.

	* When we receive a call to <<<callTerminate()>>>,you must stop the service for a call.

	* When we receive a call to <<<callReject()>>> then it should be the main activity by a message that should stop the activity responsible for outbound calls, as only we can reject a call when we perform.

	* Finally, when the application is finished the service will be in charge to eliminate the notification of the notification bar and also close the service.

	
**{CallListener}

	This interface represents the events that we receive from SIP:
	
		* <<<incomingCall(String uri)>>>. Call this method from <<controller>> when we receive an invitation to call.

		* <<<registerUserSucessful()>>>. Call this method from <<controller>>  when the user is successfully registered.

		* <<<registerUserFailed()>>>. Call this method from <<controller>>  when the user <<no>> is registered correctly.

		* <<<callSetup(NetworkConnection networkConnection)>>>. Call this method from <<controller>>  when the call is successfully established by the users.

		* <<<callTerminate()>>>. Call this method from <<controller>> when the call is completed.

		* <<<callReject()>>>.  Call this method from <<controller>> when the call has been rejected.

* {Service to an active call}

	This service will be responsible for managing an active call and will be created from the principal service when a call is set correctly.

	* When you create the service, one of the first steps to be done is to change the notification that we have in the notification bar to indicate that we have an active call, so if we go to the main menu or agenda, etc ... we can return the call without problems. Notification shall be associated with the activity that is responsible for displaying the media in the device.

	* During the creation of the service, also create audio components for both the emission and reception. The video components were created in the activity responsible for displaying the media in the device, this is  for sending audio to continue if the application is in the background, but no video.

	* When the service has began, and created the audio components properly, we must define each component as it will, if emission or reception and make them start.

	* When the audio components have started, you must start the activity will show the media in the device, then create your video components.

	* When the service is destroyed, it must:

		** Change the notification of the notification bar on the main notice.

		** Stop the audio components.

		** Tell the activity that is responsible for displaying the media in the device should be closed.

Management preferences

* {Connection}

	In the connection preferences should allow setting the following:
	
	** <<User>>:  User registration.

	** <<Password>>: Password user registration.

	** <<Domain>>: Domain user registration.

	** <<Ip Server SIP>>: Server IP  where registered users.

	** <<Port Server SIP>>: Server Port  where registered users.

* {Media}

	In the preferences of media should leave the following data set:

	* <<Maximum BandWidth>>: Indicate the max bandwidth will be used in bps(bits per second).

	* <<Video codec>>: Indicate the video codecs supported.

		* H263

		* MPEG4

	* <<Frame size>>: Indicate the frame size in pixels (width x height)

	* <<Call direction>>: Indicate the mode of each media stream.

	* <<Maximum frame rate>>: Indicate the max frame rate will be used.

	* <<Gop size>>:Indicate the max number of frames in a group of pictures, or 0 for intra_only.

	* <<Queue size>>: Indicate the number of frames will be buffered from the camera.

	* <<Audio Codec>>: Indicate the audio codecs supported.

			* AMR

			* MP2
		
	* <<Call direction>>: Indicate the mode of each media stream.
		
Management receiving and emission a call

	For both emission and reception of calls we have two activities that represent us that a contact is calling us or that we are calling us.

* Management emission

	The activity responsible for the issuance of calls will be created when a contact is chosen or known to contact you want to make the call and the display should show at least:
	
		** The name of the contact.

		** The picture of the contact, if he had.

		** A button to cancel the call.

	This activity should only show the interface for the user know you are in a call and you can cancel it. The completion of the call will class <<controller>> we have defined above.

	The closure of this activity can come from three circumstances:

		** Contact reject the call.

		** The contact accepts the call.

		** The user cancels the call.


* Management receiving

	The activity responsible for receiving calls will be created from the service control manager can get SIP events, such as an <invite> in the case of a call reception. The interface of this activity on the screen should show at least:

		** The name of the contact.

		** The picture of the contact, if he had.

		** A button to accept the call. When pressed, they must notify <<controller>> that the call has been accepted and close the activity.

		** A button to cancel the call. When pressed, they must notify <<controller>> that the call has been rejected and close the activity.

		** Vibrate. When you accept or reject the call by the vibration will stop.

	The closure of this activity can come from three circumstances:

		** Anyone who calls you, cancel the call.

		** The call is rejected.

		** We accept the call.
	

Management media (Video and Audio){Gestión del media} (Vídeo y Audio)

	The video and audio management are separated. The reason they are separated is basically that we can continue with a discussion of whether the application is in the foreground or not. Thus, the audio is handled in the service responsible for active calls and video are handled in the activity will show the media in the device, this is so not send or receive video when the device is not going to show and so do not saturate it.

* {Activity}

	This activity will be in charge of showing the media in the device and play audio through the speakers and pick up the audio we generate. This activity will have its own definition in a file <<<xml>>>, which will show the interface elements should be at least:

		* A <<<SurfaceView>>> to display the video received.

		* A <<<SurfaceView>>> to display the video that we sent.

		* A <<<Button>>> to hang up the call.

	We can add two more buttons for:

		* Manage the mute during a conversation.

		* Manage the speaker for which we want to play the audio.

	
	The creation of this activity lies in that a call has been set correctly, and the service responsible for managing active calls has been launched. The service for its part has already been responsible for managing the audio components on the other hand, as explained above. This activity will be the one responsible for managing the video components to this when creating each component should be established by associating each to his <<<SurfaceView>>> corresponding.

	Once the activity is already active, you must boot these video components to start broadcasting and receiving video and can display in each of the <<<SurfaceView>>>. As discussed above, we have several buttons to manage different aspects of the conversation.

	* If we wanted to end the call would use the button made ​​for them. To end the call using the object <<controller>>, which will recover thanks to <<<ApplicationContext>>>, using the method <<<hang()>>>. And end of the activity to end the call.

	* If we wanted to add or remove the mute button will use the conversation made ​​for them. To do this we must stop or re-boot the audio component, which also recovered thanks to <<<ApplicationContext>>>. Before we started and stopped what he was doing that component.

+---
if (audioPlayerComponent.isStarted())
	audioPlayerComponent.stop();
else
	audioPlayerComponent.start();
+---

	* We have the option to change the loudspeaker which reproduces the audio. Recover the audio component by <<<ApplicationContext>>> and we would define the type of audio component is and the speaker for which you want to play.

+---
if (audioRecorderComponent != null) {
	audioRecorderComponent.stop();
	audioRecorderComponent.unjoin(nc
			.getJoinableStream(StreamType.audio));
}

Parameters params = MSControlFactory.createParameters();
params.put(MediaComponentAndroid.STREAM_TYPE,
		AudioManager.STREAM_VOICE_CALL);
audioRecorderComponent = mediaSession
		.createMediaComponent(
				MediaComponentAndroid.AUDIO_RECORDER,
				params);

if (audioRecorderComponent != null) {
	audioRecorderComponent.join(Direction.RECV,
			nc.getJoinableStream(StreamType.audio));
	audioRecorderComponent.start();
}
+---

	* Because there is a service that manages the call, if at any time the user logs out of this activity as one who "lose" the video would be, since the activity when it comes to <<pause>> components must stop not congest video for the device. Also do not make sense to continue sending or receiving video when not viewed.

	* When we return to the activity due to the notification of the notification bar, video components must be re-created and in order to return to receive and transmit video.

	* Finally, when the activity ends, either because the button is pressed to end the call or because we have received the message from the service they have hung on the other hand, we must stop the video components.

* {Video}

	The creation of video components can be seen in the section on User Plane.

* {Audio}

	The creation of audio components can be seen in the section on User Plane.

Other classes of help

	These classes listed below are classes that can be created to facilitate the task of developing some of the features that may have application.

* {ApplicationContext}

	This class will be useful to share some information among all the activities and not lose information when the activity is in the background. Simply be a hash table in which we will be storing and collecting data as needed.

+---
public static HashMap<String, Object> contextTable = new HashMap<String, Object>();
+---

	From any part of the application can do:

	** ApplicationContext.contextTable.put("key", object), to store any type of object that we need at any time.

+---
ApplicationContext.contextTable.put("controller", controller);
+---
	** ApplicationContext.contextTable.get(objeto), to collect any type of object that we stored earlier. We will make the object which is casting.
+---
controller = (Controller) ApplicationContext.contextTable.get("controller");
+---
	

* Get the current ip

	Collect ip Android device in many applications is something that may be needed very often, so it is recommended that a small class to help us with this task. An example of the function would be:

+---
public static InetAddress getLocalAddress() {
	try {
		for (Enumeration<NetworkInterface> en = NetworkInterface
				.getNetworkInterfaces(); en.hasMoreElements();) {
			NetworkInterface intf = en.nextElement();
			for (Enumeration<InetAddress> enumIpAddr = intf
					.getInetAddresses(); enumIpAddr.hasMoreElements();) {
				InetAddress inetAddress = enumIpAddr.nextElement();
				if (!inetAddress.isLoopbackAddress()
						&& (inetAddress instanceof Inet4Address)) {
					return inetAddress;
				}
			}
		}
	} catch (SocketException e) {
		e.printStackTrace();
	}
	return null;
}
+---


* Get the contact details of the agenda

	For contact information, you should create a class to take care of it from the uri of the user. In this way, we may collect the name, photo, music associated with that contact.

	We query:

		* <<<getName(Integer Id)>>> where to get the contact's name as its identifier within the contacts. This will help us when we choose a contact from your contacts access to the application.

		* <<<getName(Intent data)>>> where to get the contact's name after choosing the contact directly from the agenda without going through the application.

		* <<<getId(String sipUri)>>> where to get the id of the contact in the phonebook from your SIP ID.

		* <<<getId(Intent data)>>> where we get the id of the contact in the phonebook.

		* <<<getSip(Intent data)>>> where we get the SIP identifier after selecting the contact directly from the agenda without going through the application.

		* <<<getPhoto(Integer id)>>> where to get the contact picture, if available.

Examples

* AndroidManifest.xml

	In this section we define:

		* The version of the application.

		* Where we want to install (in this case the memory card if possible).

		* The main application package.

+---
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	package="kas.softphone" android:versionCode="1"
	android:versionName="1.0" android:installLocation="preferExternal">
+---
	
	We define the icon and application name.

+---
<application android:icon="@drawable/icon" android:label="@string/app_name">
+---

	We define the main activity:

		* The name of the activity (SoftPhone).

		* The way to launch the activity (singleTask).

		* The <<intent-filter>> that have:

			** Main activity (android.intent.action.MAIN)

			** Start the activity from your contacts whenever you press one of them which has stored data <<<sip:xxx@xxxx.xxx>>>.
+---
<activity android:name="SoftPhone" android:label="@string/app_name"
	android:launchMode="singleTask">
	<intent-filter>
		<action android:name="android.intent.action.MAIN" />
		<category android:name="android.intent.category.LAUNCHER" />
	</intent-filter>

	<intent-filter>
		<action android:name="android.intent.action.SENDTO" />
		<category android:name="android.intent.category.DEFAULT" />
		<data android:scheme="sip" />
		<data android:scheme="imto" />
	</intent-filter>
</activity>
+---

	Definition of emission management activities and receiving calls.

+---
<activity android:name="kas.media.MediaControlIncoming"
	android:label="Media Control Incoming">
</activity>
<activity android:name="kas.media.MediaControlOutgoing"
	android:label="Media Control Outgoing">
</activity>
+---

	Defining the activity displayed by the media in the device. It adds a parameter to clear the notification bar and is full screen (<<<android:theme="@android:style\/Theme.NoTitleBar.Fullscreen">>>). In addition, it undertakes to be always horizontal orientation (<<<android:screenOrientation="landscape">>>).

+---
<activity android:name="kas.videocall.VideoCall"
	android:label="Video Call" android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
	android:screenOrientation="landscape" android:launchMode="singleTop" >
</activity>
+---

	Defining preferences management activities. In this case the orientation is vertical.

+---
<activity android:name="kas.preferences.Connection_Preferences"
	android:label="Connection Preferences" android:screenOrientation="portrait">
</activity>

<activity android:name="kas.preferences.Video_Preferences"
	android:label="Video Preferences" android:screenOrientation="portrait">
</activity>
+---

	Definition of services you will need the application.

+---
<service android:enabled="true"
	android:name="kas.softphone.SoftPhoneService" />
<service android:enabled="true"
	android:name="kas.videocall.VideoCallService" />
+---

	Definition:

		* Minimum version of the operating system must have the device (<<<uses-sdk android:minSdkVersion="8">>>).

		* Hardware and software dependencies (<<<uses-feature android:name="android.hardware.camera">>>).

		* Permits must accept the user (<<<uses-permission android:name="android.permission.CAMERA">>>).

+---
<uses-sdk android:minSdkVersion="8" />

<uses-feature android:name="android.hardware.camera"></uses-feature>
<uses-feature android:name="android.hardware.camera" android:required="false" />
<uses-feature android:name="android.hardware.camera.front" android:required="false" />
<uses-feature android:name="android.hardware.camera.autofocus"></uses-feature>

<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
<uses-permission android:name="android.permission.CAMERA"></uses-permission>
<uses-permission android:name="android.permission.RECORD_AUDIO"></uses-permission>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
<uses-permission android:name="android.permission.INTERNET"></uses-permission>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<uses-permission android:name="android.permission.READ_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.WRITE_CONTACTS"></uses-permission>
<uses-permission android:name="android.permission.READ_PHONE_STATE"></uses-permission>
+---
	
* The application

	Subscription to the main service message when you create the activity. In this way we are saying we will have a method <<<update>>> in which processes incoming messages from the main service.

+---
SoftPhoneService.setUpdateListener(this);
+---

+---
@Override
public void update(Message message) {
	 if (message.getData().containsKey("Register")) {
		if (message.getData().getString("Register").equals("Sucessful")) {
			registerSucessful();
		} else if (message.getData().getString("Register").equals("Failed")) {
			registerFailed();
		}
	} else if (message.getData().containsKey("finishActivity")) {
		if (message.getData().getString("finishActivity").equals("MEDIA_CONTROL_OUTGOING")) {
			finishActivity(MEDIA_CONTROL_OUTGOING);
		}
	}
}
+---

	When you receive one of these messages, methods should be as follows to give a warning to the user.

+---
public void registerSucessful() {
	SoftPhone.this.text = (TextView) findViewById(R.id.textRegister);
	SoftPhone.this.text.setTextSize(20);
	SoftPhone.this.text.setTextColor(Color.GREEN);
	SoftPhone.this.text.setText("Register Sucessful");

	isRegister = true;
	ApplicationContext.contextTable.put("isRegister", isRegister);
}
+---

	Subscription to the changes that may exist in the device connections. After subscribing you have to implement a new <<<PhoneStateListener>>> and in the method <<<onDataConnectionStateChanged>>>. The steps of this method are explained in the Network Control section.

+---
signalManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
signalManager.listen(signalListener,	PhoneStateListener.LISTEN_DATA_CONNECTION_STATE);
+---

+---
private final PhoneStateListener signalListener = new PhoneStateListener() {
	public void onDataConnectionStateChanged(int state) {
		if (!isExit) {
			ConnectivityManager ConnectManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);

			String sNetworkType = "No Activate";
			/*
			 * Control para sólo transmitir cuando tengamos conexión si es
			 */
			boolean backgroundEnabled = ConnectManager.getBackgroundDataSetting();
			int networkType = -1;
			NetworkInfo activeNetwork = ConnectManager.getActiveNetworkInfo();
			if (activeNetwork != null) {
				networkType = activeNetwork.getType();
			}
			boolean isAddressEqual = false;
			boolean isNetworking = false;
			InetAddress lAddressNew;
			InetAddress lAddress;

			switch (networkType) {
			case ConnectivityManager.TYPE_WIFI: 
				lAddressNew = NetworkIP.getLocalAddress();
				lAddress = (InetAddress) ApplicationContext.contextTable.get("localAddress");
				if (lAddress != null)
					if (lAddressNew.equals(lAddress))
						isAddressEqual = true;
					else
						isAddressEqual = false;
				isNetworking = true;
				break;
			case ConnectivityManager.TYPE_MOBILE: 
				ApplicationContext.contextTable.put("isNetworking", true);
				lAddressNew = NetworkIP.getLocalAddress();
				lAddress = (InetAddress) ApplicationContext.contextTable.get("localAddress");
				if (lAddress != null)
					if (lAddressNew.equals(lAddress))
						isAddressEqual = true;
					else
						isAddressEqual = false;
				isNetworking = true;
				break;
			case -1: // Disconneted
				isNetworking = false;
				break;
			default:
				break;
			}

			if (isNetworking) {
				if (!isAddressEqual) {
					controller = null;
					isRegister = false;
					ApplicationContext.contextTable.put("isRegister", isRegister);

					intentService = (Intent) ApplicationContext.contextTable.get("intentService");
					try {
						stopService(intentService);
					} catch (Exception e) {
						Log.e(LOG_TAG, "stopService " + e.getMessage()
								+ "; " + e.toString());
					}
					ApplicationContext.contextTable.clear();
					if (initControllerUAFromSettings()) {
						register();
					}
				}
			} else {
				try {
					if ((Boolean) ApplicationContext.contextTable.get("isRegister")) {
						if (controller != null)
							try {
								controller.finishUA();
								controller = null;
							} catch (Exception e1) {
								e1.printStackTrace();
							}
						isRegister = false;
						ApplicationContext.contextTable.put("isRegister", isRegister);
						intentService = (Intent) ApplicationContext.contextTable.get("intentService");
						try {
							stopService(intentService);
						} catch (Exception e) {
							Log.e(LOG_TAG, "stopService " + e.getMessage()
									+ "; " + e.toString());
						}
						ApplicationContext.contextTable.clear();
					}
				} catch (Exception e) {

				}
			}
		}
	}
};
+---

	Initialize the values ​​needed to use the method <<<initUA>>> of <<controller>>. This method will return <<<true>>> If all initialization has been properly and we have a network interface up. If we have no active network interface will return <<<false>>> In addition to exit the activity and show a message to the user.

+---
private boolean initControllerUAFromSettings() {
	try {
		SharedPreferences settings = PreferenceManager
				.getDefaultSharedPreferences(getBaseContext());
		localUser = settings.getString("LOCAL_USERNAME", "android1");
		localRealm = settings.getString("LOCAL_DOMAIN", "urjc.es");
		proxyIP = settings.getString("PROXY_IP", "193.147.51.17");
		proxyPort = Integer.parseInt(settings.getString("PROXY_PORT",
				"5060"));

		this.textUser = (TextView) findViewById(R.id.textUser);
		this.textUser.setText("User: " + localUser + "@" + localRealm);

		this.textServer = (TextView) findViewById(R.id.textServer);
		this.textServer.setText("Server: " + proxyIP + ":" + proxyPort);

		ni = connManager.getActiveNetworkInfo();
		String conType = ni.getTypeName();

		if ("WIFI".equalsIgnoreCase(conType))
			connectionType = ConnectionType.WIFI;
		else if ("MOBILE".equalsIgnoreCase(conType))
			connectionType = ConnectionType.MOBILE;

		this.audioCodecs = getAudioCodecsFromSettings();
		this.videoCodecs = getVideoCodecsFromSettings();
		this.localAddress = NetworkIP.getLocalAddress();
		ApplicationContext.contextTable.put("localAddress", localAddress);
		return true;
	} catch (Exception e) {
		Toast.makeText(SoftPhone.this,
				"SoftPhone: Please enable any network interface.",
				Toast.LENGTH_SHORT).show();

		finish();
		return false;
	}

}
+---

	Collect data from media preferences.

+---
private ArrayList<VideoCodecType> getVideoCodecsFromSettings() {
	SharedPreferences settings = PreferenceManager
			.getDefaultSharedPreferences(getBaseContext());

	ArrayList<VideoCodecType> selectedVideoCodecs = new ArrayList<VideoCodecType>();
	if (settings.getBoolean("H263_CODEC", false))
		selectedVideoCodecs.add(VideoCodecType.H263);
	if (settings.getBoolean("MPEG4_CODEC", false))
		selectedVideoCodecs.add(VideoCodecType.MPEG4);
	if (settings.getBoolean("H264_CODEC", false))
		selectedVideoCodecs.add(VideoCodecType.H264);

	return selectedVideoCodecs;
}

private ArrayList<AudioCodecType> getAudioCodecsFromSettings() {
	SharedPreferences settings = PreferenceManager
			.getDefaultSharedPreferences(getBaseContext());

	ArrayList<AudioCodecType> selectedAudioCodecs = new ArrayList<AudioCodecType>();
	if (settings.getBoolean("AMR_AUDIO_CODEC", false))
		selectedAudioCodecs.add(AudioCodecType.AMR);
	if (settings.getBoolean("MP2_AUDIO_CODEC", false))
		selectedAudioCodecs.add(AudioCodecType.MP2);
	if (settings.getBoolean("AAC_AUDIO_CODEC", false))
		selectedAudioCodecs.add(AudioCodecType.AAC);

	return selectedAudioCodecs;
}
+---

	Once the necessary variables are initialized make a register and start the principal service.

+---
private void register() {
	if (controller == null)
		controller = new Controller();
	intentService = (Intent) ApplicationContext.contextTable.get("intentService");
	if (intentService == null) {
		intentService = new Intent(this, SoftPhoneService.class);
		ApplicationContext.contextTable.put("intentService", intentService);
		startService(intentService);
	}

	if (initControllerUAFromSettings())
		initUA();
}
+---

	In the method <<<register>>> appears the call to <<<initUA>>> which finally made ​​the call to <<<initUA>>> of <<controller>>. Where it really make the registration and initialization of structures to SIP.

+---
private void initUA() {
	try {
		controller.initUA(audioCodecs, videoCodecs, localAddress,
				connectionType, proxyIP, proxyPort, localUser, localRealm);
		ApplicationContext.contextTable.put("controller", controller);
	} catch (Exception e) {
		e.printStackTrace();
	}
}
+---

	Make a call to a contact.

		* Using the button to access the contacts.

+---
final Button buttonContacts = (Button) findViewById(R.id.contacts);
	buttonContacts.setOnClickListener(new OnClickListener() {

		@Override
		public void onClick(View v) {
			try {
				openContacts();
			} catch (Exception e) {
				Log.e("Error Search", e.toString());
			}
		}
	});
private void openContacts() {
	Intent intentContacts = new Intent(Intent.ACTION_PICK, 	ContactsContract.Contacts.CONTENT_URI);
	startActivityForResult(intentContacts, PICK_CONTACT_REQUEST);
}
+---	

		And within <<<onActivityResult(int requestCode, Intent resultCode, data) int>>> we have:

+---
if (requestCode == PICK_CONTACT_REQUEST) {
	if (resultCode == RESULT_OK) {
		Integer id = null;
		String sip = null;
		String name = null;

		id = controlcontacts.getId(data);
		sip = controlcontacts.getSip(data);
		name = controlcontacts.getName(data);

		if (sip != null) {
			Toast.makeText(SoftPhone.this, name + ", SIP:" + sip,
					Toast.LENGTH_SHORT).show();
			call("sip:" + sip, id);
		} else
			Toast.makeText(SoftPhone.this, name + ", No tiene SIP:",
					Toast.LENGTH_SHORT).show();
	}
}
+---

		* Fill in the text box to type a contact and using the call button.

+---
final Button buttonCall = (Button) findViewById(R.id.call);
	buttonCall.setOnClickListener(new OnClickListener() {

		@Override
		public void onClick(View v) {
			TextView textRemoteUri = (TextView) findViewById(R.id.textRemoteUri);
			String remoteURI = "sip:";

			remoteURI += textRemoteUri.getText().toString();
			Integer idContact;
			idContact = controlcontacts.getId(textRemoteUri.getText().toString());
			call(remoteURI, idContact);
	}
});
+---

	The method <<<call>>> to make a call.

+---
private void call(String remoteURI, Integer id) {
	if (controller != null) {
		if (controller.getUa() == null)
			initControllerUAFromSettings();
		try {
			controller.call(remoteURI);
			Intent mediaIntent = new Intent(SoftPhone.this, MediaControlOutgoing.class);

			mediaIntent.putExtra("Id", id);
			mediaIntent.putExtra("Uri", remoteURI);
			startActivityForResult(mediaIntent, MEDIA_CONTROL_OUTGOING);
		} catch (Exception e) {
			e.printStackTrace();
		}
	} else
		notRegister();
}
+---

	When we destroy the activity.

+---
if (isExit) {
	signalManager.listen(signalListener, PhoneStateListener.LISTEN_NONE);
	if (controller != null)
		controller.finishUA();
	isRegister = false;
	ApplicationContext.contextTable.put("isRegister", isRegister);

	intentService = (Intent) ApplicationContext.contextTable
			.get("intentService");
	try {
		stopService(intentService);
	} catch (Exception e) {
		Log.e(LOG_TAG, "stopService " + e.getMessage() + "; " + e.toString());
	}
	ApplicationContext.contextTable.clear();
}
+---

* Services

** {{Principal service}}

	The definition of a notification in the notification bar, with the name <<Softphone>> that is associated with class <<SoftPhone.class>>.

+---
private NotificationManager mNotificationMgr;
private final static int NOTIF_SOFTPHONE = 1;
private final static int NOTIF_VIDEOCALL = 1;

private Notification mNotif;
private PendingIntent mNotifContentIntent;
private Intent notifIntent;
private String notificationTitle = "Softphone";
private static final int IC_LEVEL_ORANGE = 0;

mNotificationMgr = (NotificationManager) this
			.getSystemService(Context.NOTIFICATION_SERVICE);

mNotif = new Notification(R.drawable.icon, notificationTitle,
		System.currentTimeMillis());
mNotif.iconLevel = IC_LEVEL_ORANGE;
mNotif.flags |= Notification.FLAG_ONGOING_EVENT;

notifIntent = new Intent(this, SoftPhone.class);
mNotifContentIntent = PendingIntent
		.getActivity(this, 0, notifIntent, 0);
mNotif.setLatestEventInfo(this, notificationTitle, "",
		mNotifContentIntent);

mNotificationMgr.notify(NOTIF_SOFTPHONE, mNotif);
+---

	Collect <<controller>> of <<<ApplicationContext>>> and report <<controller>> implement the service <<<CallListener>>>.

+---
Controller controller = (Controller) ApplicationContext.contextTable
			.get("controller");
if (controller != null)
		controller.addListener(this);
+---

	One possible implementation of <<<incomingCall(String uri)>>>. Then run as explained in the documentation activity that is responsible for managing incoming calls, by adding <<<putExtra>>> the <<<uri>>> that has reached us.

+---
@Override
public void incomingCall(String uri) {
	Log.d(LOG_TAG, "Invite received");
	Intent mediaIntent = new Intent(this, MediaControlIncoming.class);
	mediaIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	mediaIntent.putExtra("Uri", uri);
	startActivity(mediaIntent);
	
}
+---
	
	One possible implementation of <<<callSetup>>>. The call has been established so we must tell the principal application should stop the activity that managing outgoing calls with a message (<<<handler.sendMessage(msg)>>>). And we must start the service that manages active calls.

+---
@Override
public void callSetup(NetworkConnection networkConnection) {
	ApplicationContext.contextTable.put("networkConnection", networkConnection);
	
	Message msg = new Message();
	Bundle b = new Bundle();
	b.putString("finishActivity", "MEDIA_CONTROL_OUTGOING");
	msg.setData(b);
	handler.sendMessage(msg);

	videoCallIntent = new Intent(this, VideoCallService.class);
	videoCallIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
	startService(videoCallIntent);
}
+---
	
	Method for sending messages to the application signed. In this case will be the main application.

+---
public interface ServiceUpdateUIListener {
	public void update(Message message);
}


public static ServiceUpdateUIListener UI_UPDATE_LISTENER;

public static void setUpdateListener(ServiceUpdateUIListener l) {
	UI_UPDATE_LISTENER = l;
}

private Handler handler = new Handler() {
	@Override
	public void handleMessage(Message msg) {
		UI_UPDATE_LISTENER.update(msg);
	}
};
+---

	By destroying the service, cancel the notifications that may be in the notification bar and stop the service to manage active calls.

+---
mNotificationMgr.cancel(NOTIF_SOFTPHONE);
mNotificationMgr.cancel(NOTIF_VIDEOCALL);
stopService(videoCallIntent);
+---


** {{Service to an active call}}

	Recovery <<controller>> from <<<ApplicationContext>>>. MediaSession object creation and audio components. Objects are also added audio component in the <<<ApplicationContext>>> to access them from another part of the application.

+---
Controller controller = (Controller) ApplicationContext.contextTable
			.get("controller");
if (controller == null) 		
	return;

MediaSessionAndroid mediaSession = controller.getMediaSession();

try {
	audioPlayerComponent = mediaSession.createMediaComponent(MediaComponentAndroid.AUDIO_PLAYER, Parameters.NO_PARAMETER);
	
	Parameters params = MSControlFactory.createParameters();
	params.put(MediaComponentAndroid.STREAM_TYPE, AudioManager.STREAM_MUSIC);
	audioRecorderComponent = mediaSession.createMediaComponent(MediaComponentAndroid.AUDIO_RECORDER, params);
} catch (MsControlException e) {
	e.printStackTrace();
}
ApplicationContext.contextTable.put("audioPlayerComponent", audioPlayerComponent);
ApplicationContext.contextTable.put("audioRecorderComponent", audioRecorderComponent);
+---

	Recovery <<<NetworkConnection>>> of <<<ApplicationContext>>> and boot configuration and audio components.

+---
NetworkConnection nc = (NetworkConnection) ApplicationContext.contextTable
	.get("networkConnection");
if (nc == null) 
	return;
		
try {
	if (audioPlayerComponent != null) {
		audioPlayerComponent.join(Direction.SEND,
				nc.getJoinableStream(StreamType.audio));
		audioPlayerComponent.start();
	}
	if (audioRecorderComponent != null) {
		audioRecorderComponent.join(Direction.RECV,
				nc.getJoinableStream(StreamType.audio));
		audioRecorderComponent.start();
	}
	
} catch (MsControlException e) {
	e.printStackTrace();
}
+---

	Start the activity that controls the management of a call.

+---
videoCallIntent = new Intent(this, VideoCall.class);
videoCallIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(videoCallIntent);
+---

	By destroying the service, change the notification for a call by the application.

+---
mNotificationMgr.cancel(NOTIF_VIDEOCALL);
mNotif = new Notification(R.drawable.icon, notificationTitleSoft,
		System.currentTimeMillis());

notifIntent = new Intent(this, SoftPhone.class);
mNotifContentIntent = PendingIntent
		.getActivity(this, 0, notifIntent, 0);
mNotif.setLatestEventInfo(this, notificationTitleSoft, "",
		mNotifContentIntent);

mNotificationMgr.notify(NOTIF_SOFTPHONE, mNotif);
+---

	Stop the audio components.

+---
if (audioPlayerComponent != null)
	audioPlayerComponent.stop();

if (audioRecorderComponent != null)
	audioRecorderComponent.stop();
+---

	And send a message confirming that the call has ended. In this case, you will be sent to the activity which manages the active call as I have seen in the main service.

+---
Message msg = new Message();
Bundle b = new Bundle();
b.putString("Call", "Terminate");
msg.setData(b);
handler.sendMessage(msg);
+---

* Contact Management

	Possible implementation of obtaining a contact name from your <<id>>. The idea is to make an inquiry, like a sql query in which we indicate the user ID we want. If it exists, we can return the name.

+---
public String getName(Integer id) {

	int contact_id = -1;
	String name = "";
	contact_id = id;

	Cursor pidcursor = c.getContentResolver().query(
			ContactsContract.Contacts.CONTENT_URI,
			new String[] { ContactsContract.Contacts.DISPLAY_NAME },
			ContactsContract.Contacts._ID + "=" + contact_id, null, null);
	if (pidcursor != null) {
		if (pidcursor.moveToFirst()) {
			name = pidcursor.getString(0);
		}
	}
	return name;
}
+---

	Another way of performing this query is using the data that Android provides us when we access from the agenda. In this case the query is performed using data <<<Intent>>>.

+---
public String getName(Intent data) {
	Cursor cursor = c.getContentResolver().query(data.getData(), null,
			null, null, null);

	String name = null;

	if (cursor.moveToFirst()) {
		int nameIdx = cursor
				.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME);

		name = cursor.getString(nameIdx);
	}
	if (name != null)
		return name;
	else
		return null;
}
+---

	To recover the <<id>> of a possible contact, looking through his <<<uri>>> into contact with any content type <<<CONTENT_URI>>>. If the contact is returned there <<id>>.

+---
public Integer getId(String sipUri) {

	Integer idContact = -1;
	String sipUriContact = "";

	String whereIm = ContactsContract.Data.MIMETYPE + " = ?";
	String[] whereParametersIm = new String[] { ContactsContract.CommonDataKinds.Im.CONTENT_ITEM_TYPE };

	Cursor contactsIm = c.getContentResolver().query(
			ContactsContract.Data.CONTENT_URI, null, whereIm,
			whereParametersIm, null);

	while (contactsIm.moveToNext()) {

		sipUriContact = contactsIm.getString(contactsIm
				.getColumnIndexOrThrow(ContactsContract.Data.DATA1));
		if (sipUri.equals(sipUriContact)) {
			int idIdx = contactsIm
					.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.CONTACT_ID);
			idContact = contactsIm.getInt(idIdx);

			break;
		}
	}
	contactsIm.close();
	return idContact;
}
+---

	Recovery the photo  for a contact using your <<id>>. First contact will be sought on the agenda for once found, get your picture using the <<<photo_id>>>.

+---
public Bitmap getPhoto(Integer id) {

	byte[] photo = null;
	Bitmap bm = null;
	int contact_id = -1;
	int photo_id = -1;

	if (id != -1){
		contact_id = id;

		Cursor pidcursor = c.getContentResolver().query(
				ContactsContract.Contacts.CONTENT_URI,
				new String[] { ContactsContract.Contacts.PHOTO_ID },
				ContactsContract.Contacts._ID + "=" + contact_id, null,
				null);
		if (pidcursor != null) {
			if (pidcursor.moveToFirst()) {
				photo_id = pidcursor.getInt(0);
			}
		}

		Cursor pcursor = c.getContentResolver().query(
				ContactsContract.Data.CONTENT_URI,
				new String[] { ContactsContract.Data.DATA15 },
				ContactsContract.Data._ID + "=" + photo_id, null, null);
		if (pcursor.moveToFirst()) {
			photo = pcursor.getBlob(0);
		}
		if (photo != null) {
			bm = BitmapFactory.decodeByteArray(photo, 0, photo.length);
		}
	}
	else Log.d(LOG_TAG, "Id is null, not contatc");
	return bm;
}
+---

* Call Management

** Management emission a call

	When creating the activity data is retrieved as the <<<uri>>> and <<id>> and from there you try to retrieve the data and the photo of the contact that calls from the phonebook. If you are on the agenda is filled with data interface so we know who to call.

+---
Bundle extras = getIntent().getExtras();
String uri = (String) extras.getSerializable("Uri");
Integer id = (Integer) extras.getSerializable("Id");
TextView text = (TextView) findViewById(R.id.outgoing_sip);
text.setText(uri);

ImageView imageCall = (ImageView) findViewById(R.id.image_call);

ControlContacts controlcontacts = new ControlContacts(this);

Bitmap bm = controlcontacts.getPhoto(id);

if (bm != null) {

	imageCall.setImageBitmap(bm);
}
+---

	Cancelar una llamada saliente.

+---
controller.cancel();
finish();
+---

** Management receiving a call

	When creating the activity data is retrieved as the <<<uri>>> and from there you try to retrieve the data and the photo of the contact that calls from the phonebook. If you are on the agenda is filled with data interface so we know who is calling us.

+---
Bundle extras = getIntent().getExtras();

String uri = (String) extras.getSerializable("Uri");

TextView text = (TextView) findViewById(R.id.incoming_sip);
text.setText(uri);

String[] sipArray = uri.split(":");
String sipUri = "";
if (sipArray.length > 1) sipUri = sipArray[1];
else sipUri = sipArray[0];

Integer idContact = controlcontacts.getId(sipUri);

if (!idContact.equals("")){
	ImageView imageCall = (ImageView) findViewById(R.id.image_call);
	Bitmap bm = controlcontacts.getPhoto(idContact);
	if (bm != null) {
		imageCall.setImageBitmap(bm);
	}
}
+---

	Operation of the vibrator to simulate the call.

+---
Vibrator vibrator;
vibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);
long[] pattern = { 0, 1000, 2000, 3000 };

vibrator.vibrate(pattern, 1);
+---

	Accepting a call. Cancel vibration, accept the call to <<<aceptCall()>>> and end the activity.

+---
vibrator.cancel();
if (controller != null){
	try {
		controller.aceptCall();
	} catch (Exception e) {
		e.printStackTrace();
	}
}
finish();
+---

	To reject the call would be the same but using:

+---
controller.reject();
+---


